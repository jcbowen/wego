# 06-消息加解密说明

## 概述

微信开放平台要求第三方平台对接收和发送的消息进行加密解密，确保通信安全。wxopen组件实现了完整的消息加解密功能，符合微信安全规范。

## 加解密原理

### 1. 加密流程
1. 生成16位随机字符串
2. 将明文消息与随机字符串拼接
3. 使用AES-256-CBC模式加密
4. 生成消息签名（SHA1）
5. 组合成最终加密消息

### 2. 解密流程
1. 验证消息签名
2. 使用AES-256-CBC模式解密
3. 提取随机字符串和明文消息
4. 验证随机字符串

## wxopen组件实现

### 加解密核心方法

```go
// 加密消息
func (crypto *WXBizMsgCrypt) EncryptMsg(replyMsg, timestamp, nonce string) ([]byte, error) {
    // 生成16位随机字符串
    randomStr := generateRandomStr(16)
    
    // 拼接明文
    plainText := bytes.Join([][]byte{
        []byte(randomStr),
        []byte(strconv.Itoa(len(replyMsg))),
        []byte(replyMsg),
        []byte(crypto.appID),
    }, []byte{})
    
    // AES加密
    encrypted, err := aesEncrypt(plainText, crypto.aesKey)
    if err != nil {
        return nil, err
    }
    
    // 生成签名
    signature := genSignature(crypto.token, timestamp, nonce, string(encrypted))
    
    // 组合XML响应
    return formatEncryptResponse(encrypted, signature, timestamp, nonce), nil
}

// 解密消息
func (crypto *WXBizMsgCrypt) DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg string) ([]byte, error) {
    // 验证签名
    if !validateSignature(crypto.token, timestamp, nonce, encryptedMsg, msgSignature) {
        return nil, fmt.Errorf("签名验证失败")
    }
    
    // Base64解码
    encryptedData, err := base64.StdEncoding.DecodeString(encryptedMsg)
    if err != nil {
        return nil, err
    }
    
    // AES解密
    decrypted, err := aesDecrypt(encryptedData, crypto.aesKey)
    if err != nil {
        return nil, err
    }
    
    // 解析解密结果
    randomStr, msgLen, msg, appID, err := parseDecryptedData(decrypted)
    if err != nil {
        return nil, err
    }
    
    // 验证AppID
    if appID != crypto.appID {
        return nil, fmt.Errorf("AppID不匹配")
    }
    
    return msg, nil
}
```

### 签名验证

```go
// 生成签名
func genSignature(token, timestamp, nonce, encrypted string) string {
    params := []string{token, timestamp, nonce, encrypted}
    sort.Strings(params)
    
    combined := strings.Join(params, "")
    hash := sha1.Sum([]byte(combined))
    
    return hex.EncodeToString(hash[:])
}

// 验证签名
func validateSignature(token, timestamp, nonce, encrypted, msgSignature string) bool {
    expectedSignature := genSignature(token, timestamp, nonce, encrypted)
    return expectedSignature == msgSignature
}
```

## 完整示例

### 1. 加解密使用示例

```go
package main

import (
    "fmt"
    "github.com/jcbowen/jcbaseGo/component/wego"
)

func main() {
    // 初始化加解密器
    crypto := wego.NewWXBizMsgCrypt(
        "your_token",
        "your_encoding_aes_key", 
        "your_app_id",
    )
    
    // 示例：解密消息
    msgSignature := "接收到的消息签名"
    timestamp := "时间戳"
    nonce := "随机数"
    encryptedMsg := "加密的消息内容"
    
    decryptedMsg, err := crypto.DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg)
    if err != nil {
        fmt.Printf("解密失败: %v\n", err)
        return
    }
    
    fmt.Printf("解密后的消息: %s\n", string(decryptedMsg))
    
    // 示例：加密回复消息
    replyMsg := `<xml><ToUserName><![CDATA[toUser]]></ToUserName><FromUserName><![CDATA[fromUser]]></FromUserName><CreateTime>12345678</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[你好]]></Content></xml>`
    
    encryptedReply, err := crypto.EncryptMsg(replyMsg, timestamp, nonce)
    if err != nil {
        fmt.Printf("加密失败: %v\n", err)
        return
    }
    
    fmt.Printf("加密后的回复: %s\n", string(encryptedReply))
}
```

### 2. HTTP服务器集成

```go
func handleWxCallback(w http.ResponseWriter, r *http.Request) {
    crypto := wego.NewWXBizMsgCrypt("your_token", "your_encoding_aes_key", "your_app_id")
    
    // 获取URL参数
    signature := r.URL.Query().Get("msg_signature")
    timestamp := r.URL.Query().Get("timestamp") 
    nonce := r.URL.Query().Get("nonce")
    
    // 处理URL验证（首次配置）
    if echostr := r.URL.Query().Get("echostr"); echostr != "" {
        decryptedEchostr, err := crypto.VerifyURL(signature, timestamp, nonce, echostr)
        if err != nil {
            http.Error(w, "URL验证失败", http.StatusBadRequest)
            return
        }
        w.Write([]byte(decryptedEchostr))
        return
    }
    
    // 读取请求体
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "读取请求体失败", http.StatusBadRequest)
        return
    }
    
    // 解析XML获取加密消息
    var encryptedMsg string
    // 解析逻辑...
    
    // 解密消息
    decryptedMsg, err := crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    if err != nil {
        http.Error(w, "消息解密失败", http.StatusBadRequest)
        return
    }
    
    // 处理业务逻辑
    response := processBusinessLogic(decryptedMsg)
    
    // 加密回复
    encryptedResponse, err := crypto.EncryptMsg(response, timestamp, nonce)
    if err != nil {
        http.Error(w, "回复加密失败", http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/xml")
    w.Write(encryptedResponse)
}
```

## 加解密最佳实践

### 1. 密钥管理
- 安全存储EncodingAESKey
- 定期更换密钥
- 实现密钥备份机制

### 2. 错误处理
- 完善的错误日志记录
- 优雅的错误恢复
- 监控加解密成功率

### 3. 性能优化
- 缓存加解密实例
- 使用连接池
- 避免重复初始化

### 4. 安全考虑
- 验证所有输入参数
- 防止重放攻击
- 实现速率限制

## 注意事项

### 1. 编码要求
- EncodingAESKey必须是43位
- 使用Base64编码
- 注意字符编码问题

### 2. 时间戳验证
- 验证时间戳有效性
- 防止重放攻击
- 设置合理的时间窗口

### 3. 随机数管理
- 使用安全的随机数生成器
- 确保随机数唯一性
- 实现随机数验证

## 常见问题

### Q: 签名验证失败
A: 检查Token、时间戳、随机数、加密消息的顺序和内容

### Q: 解密失败
A: 检查EncodingAESKey是否正确、消息格式是否标准

### Q: AppID不匹配
A: 检查加解密时使用的AppID与配置是否一致

## 相关API

- `EncryptMsg()` - 加密消息
- `DecryptMsg()` - 解密消息
- `VerifyURL()` - 验证URL
- `ValidateSignature()` - 验证签名

通过wxopen组件的加解密功能，您可以确保与微信服务器的通信安全可靠。