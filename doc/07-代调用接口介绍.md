# 08-代调用接口介绍

## 概述

代调用接口是第三方平台代授权方（公众号/小程序）调用微信API的核心功能。WeGo库提供了完整的代调用接口实现，支持各种微信API的代理调用。

## 代调用原理

### 1. 调用流程
1. 获取授权方AccessToken
2. 构造API请求参数
3. 发送HTTP请求到微信服务器
4. 处理API响应结果
5. 错误处理和重试机制

### 2. 权限说明
- 第三方平台需要获得相应权限
- 授权方需要授权相应接口
- 接口调用受频率限制

## WeGo库实现

### AuthorizerClient结构

根据实际的代码实现，授权方客户端结构如下：

```go
// AuthorizerClient 授权方客户端
type AuthorizerClient struct {
    authorizerAppID string  // 授权方AppID
    client          *WegoClient  // 第三方平台客户端
    httpClient      *http.Client // HTTP客户端
    logger          Logger       // 日志记录器
}

// 创建授权方客户端
func (c *WegoClient) Auth(authorizerAppID string) *AuthorizerClient {
    return &AuthorizerClient{
        authorizerAppID: authorizerAppID,
        client:          c,
        httpClient:      c.httpClient,
        logger:          c.logger,
    }
}
```

### 代调用核心方法

```go
import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "net/url"
    "strings"
    "time"
)

// APIResponse 微信API通用响应结构
type APIResponse struct {
    ErrCode int    `json:"errcode"`
    ErrMsg  string `json:"errmsg"`
}

// CallAPI 代调用API（支持context）
func (ac *AuthorizerClient) CallAPI(ctx context.Context, apiURL string, params interface{}) ([]byte, error) {
    // 1. 获取授权方AccessToken
    token, err := ac.client.GetAuthorizerAccessToken(ctx, ac.authorizerAppID)
    if err != nil {
        return nil, fmt.Errorf("获取AccessToken失败: %v", err)
    }
    
    // 2. 构造完整URL
    fullURL := fmt.Sprintf("%s?access_token=%s", apiURL, token.AccessToken)
    
    // 3. 创建HTTP请求
    var req *http.Request
    if params != nil {
        // POST请求
        jsonData, err := json.Marshal(params)
        if err != nil {
            return nil, fmt.Errorf("参数序列化失败: %v", err)
        }
        
        req, err = http.NewRequestWithContext(ctx, "POST", fullURL, strings.NewReader(string(jsonData)))
        if err != nil {
            return nil, fmt.Errorf("创建请求失败: %v", err)
        }
        req.Header.Set("Content-Type", "application/json")
    } else {
        // GET请求
        req, err = http.NewRequestWithContext(ctx, "GET", fullURL, nil)
        if err != nil {
            return nil, fmt.Errorf("创建请求失败: %v", err)
        }
    }
    
    // 4. 发送HTTP请求
    resp, err := ac.httpClient.Do(req)
    if err != nil {
        return nil, fmt.Errorf("API调用失败: %v", err)
    }
    defer resp.Body.Close()
    
    // 5. 读取响应
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %v", err)
    }
    
    // 6. 解析响应
    var apiResp APIResponse
    if err := json.Unmarshal(respBody, &apiResp); err != nil {
        return nil, fmt.Errorf("响应解析失败: %v", err)
    }
    
    // 7. 检查错误码
    if apiResp.ErrCode != 0 {
        return nil, fmt.Errorf("API返回错误: %d - %s", apiResp.ErrCode, apiResp.ErrMsg)
    }
    
    return respBody, nil
}

// CallAPIWithQuery 支持查询参数的API调用
func (ac *AuthorizerClient) CallAPIWithQuery(ctx context.Context, baseURL string, queryParams map[string]string, postData interface{}) ([]byte, error) {
    // 获取授权方AccessToken
    token, err := ac.client.GetAuthorizerAccessToken(ctx, ac.authorizerAppID)
    if err != nil {
        return nil, fmt.Errorf("获取AccessToken失败: %v", err)
    }
    
    // 构造查询参数
    params := url.Values{}
    params.Set("access_token", token.AccessToken)
    for key, value := range queryParams {
        params.Set(key, value)
    }
    
    fullURL := fmt.Sprintf("%s?%s", baseURL, params.Encode())
    
    // 根据是否有postData决定请求方法
    if postData != nil {
        return ac.CallAPI(ctx, fullURL, postData)
    }
    return ac.CallAPI(ctx, fullURL, nil)
}
```

## 常用API封装

### 1. 用户管理API

```go
import "context"

// 获取用户列表
func (ac *AuthorizerClient) GetUserList(ctx context.Context, nextOpenID string) ([]string, int, int, string, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/user/get"
    
    queryParams := map[string]string{
        "next_openid": nextOpenID,
    }
    
    respBody, err := ac.CallAPIWithQuery(ctx, apiURL, queryParams, nil)
    if err != nil {
        return nil, 0, 0, "", err
    }
    
    var result struct {
        Total int      `json:"total"`
        Count int      `json:"count"`
        Data  struct {
            OpenIDs []string `json:"openid"`
        } `json:"data"`
        NextOpenID string `json:"next_openid"`
    }
    
    if err := json.Unmarshal(respBody, &result); err != nil {
        return nil, 0, 0, "", err
    }
    
    return result.Data.OpenIDs, result.Total, result.Count, result.NextOpenID, nil
}

// 获取用户信息
func (ac *AuthorizerClient) GetUserInfo(ctx context.Context, openID string) (*UserInfo, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/user/info"
    
    queryParams := map[string]string{
        "openid": openID,
        "lang":   "zh_CN",
    }
    
    respBody, err := ac.CallAPIWithQuery(ctx, apiURL, queryParams, nil)
    if err != nil {
        return nil, err
    }
    
    var userInfo UserInfo
    if err := json.Unmarshal(respBody, &userInfo); err != nil {
        return nil, err
    }
    
    return &userInfo, nil
}
```

### 2. 消息发送API

```go
// 发送客服消息
func (ac *AuthorizerClient) SendCustomMessage(ctx context.Context, message interface{}) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/message/custom/send"
    
    _, err := ac.CallAPI(ctx, apiURL, message)
    return err
}

// 发送文本消息
func (ac *AuthorizerClient) SendTextMessage(ctx context.Context, toUser, content string) error {
    message := map[string]interface{}{
        "touser":  toUser,
        "msgtype": "text",
        "text": map[string]string{
            "content": content,
        },
    }
    return ac.SendCustomMessage(ctx, message)
}

// 发送图片消息
func (ac *AuthorizerClient) SendImageMessage(ctx context.Context, toUser, mediaID string) error {
    message := map[string]interface{}{
        "touser":  toUser,
        "msgtype": "image",
        "image": map[string]string{
            "media_id": mediaID,
        },
    }
    return ac.SendCustomMessage(ctx, message)
}

// 发送图文消息
func (ac *AuthorizerClient) SendNewsMessage(ctx context.Context, toUser string, articles []Article) error {
    message := map[string]interface{}{
        "touser":  toUser,
        "msgtype": "news",
        "news": map[string]interface{}{
            "articles": articles,
        },
    }
    return ac.SendCustomMessage(ctx, message)
}
```

### 3. 菜单管理API

```go
// 创建自定义菜单
func (ac *AuthorizerClient) CreateMenu(ctx context.Context, menu *Menu) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/create"
    
    _, err := ac.CallAPI(ctx, apiURL, menu)
    return err
}

// 删除自定义菜单
func (ac *AuthorizerClient) DeleteMenu(ctx context.Context) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/delete"
    
    _, err := ac.CallAPI(ctx, apiURL, nil)
    return err
}

// 获取菜单
func (ac *AuthorizerClient) GetMenu(ctx context.Context) (*Menu, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/get"
    
    respBody, err := ac.CallAPI(ctx, apiURL, nil)
    if err != nil {
        return nil, err
    }
    
    var menu Menu
    if err := json.Unmarshal(respBody, &menu); err != nil {
        return nil, err
    }
    
    return &menu, nil
}

// 创建个性化菜单
func (ac *AuthorizerClient) CreateConditionalMenu(ctx context.Context, menu *ConditionalMenu) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/addconditional"
    
    _, err := ac.CallAPI(ctx, apiURL, menu)
    return err
}

// 删除个性化菜单
func (ac *AuthorizerClient) DeleteConditionalMenu(ctx context.Context, menuID string) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/delconditional"
    
    params := map[string]interface{}{
        "menuid": menuID,
    }
    
    _, err := ac.CallAPI(ctx, apiURL, params)
    return err
}
```

## 完整示例

### 1. 用户管理示例

```go
package main

import (
    "context"
    "fmt"
    "log"
    "github.com/jcbowen/wego"
)

func main() {
    config := &wego.WeGoConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWeGo(config)
    
    // 获取授权方客户端
    authorizerAppID := "授权方AppID"
    authorizerClient := client.Auth(authorizerAppID)
    
    ctx := context.Background()
    
    // 获取用户列表
    users, total, count, nextOpenID, err := authorizerClient.GetUserList(ctx, "")
    if err != nil {
        log.Printf("获取用户列表失败: %v\n", err)
        return
    }
    
    fmt.Printf("用户总数: %d, 本次获取: %d\n", total, count)
    
    // 获取第一个用户的信息
    if len(users) > 0 {
        userInfo, err := authorizerClient.GetUserInfo(ctx, users[0])
        if err != nil {
            log.Printf("获取用户信息失败: %v\n", err)
            return
        }
        
        fmt.Printf("用户昵称: %s, 城市: %s\n", userInfo.Nickname, userInfo.City)
        
        // 发送欢迎消息
        err = authorizerClient.SendTextMessage(ctx, users[0], "欢迎使用我们的服务！")
        if err != nil {
            log.Printf("发送消息失败: %v\n", err)
            return
        }
        
        fmt.Println("欢迎消息发送成功！")
    }
}
```

### 2. 菜单管理示例

```go
import "context"

func manageMenu(authorizerClient *wego.AuthorizerClient) error {
    ctx := context.Background()
    
    // 创建菜单
    menu := &wego.Menu{
        Button: []wego.MenuButton{
            {
                Type: "click",
                Name: "今日歌曲",
                Key:  "V1001_TODAY_MUSIC",
            },
            {
                Name: "菜单",
                SubButton: []wego.MenuButton{
                    {
                        Type: "view",
                        Name: "搜索",
                        URL:  "http://www.soso.com/",
                    },
                    {
                        Type: "click",
                        Name: "赞一下我们",
                        Key:  "V1001_GOOD",
                    },
                },
            },
        },
    }
    
    // 创建菜单
    if err := authorizerClient.CreateMenu(ctx, menu); err != nil {
        return fmt.Errorf("创建菜单失败: %v", err)
    }
    
    fmt.Println("菜单创建成功！")
    
    // 获取菜单
    currentMenu, err := authorizerClient.GetMenu(ctx)
    if err != nil {
        return fmt.Errorf("获取菜单失败: %v", err)
    }
    
    fmt.Printf("当前菜单按钮数量: %d\n", len(currentMenu.Button))
    
    return nil
}
```

## 错误处理

### 1. Token过期处理

```go
import "context"

// 带重试的API调用
func (ac *AuthorizerClient) CallAPIWithRetry(ctx context.Context, apiURL string, params interface{}, maxRetries int) (*wego.APIResponse, error) {
    for i := 0; i < maxRetries; i++ {
        resp, err := ac.CallAPI(ctx, apiURL, params)
        if err == nil {
            return resp, nil
        }
        
        // 检查是否是Token过期错误
        if strings.Contains(err.Error(), "40001") || strings.Contains(err.Error(), "42001") {
            // Token过期，清除缓存并重试
            ac.client.storage.ClearAuthorizerAccessToken(&wego.AuthorizerAccessToken{
                AuthorizerAppID: ac.authorizerAppID,
            })
            continue
        }
        
        // 其他错误，直接返回
        return nil, err
    }
    
    return nil, fmt.Errorf("API调用重试%d次后失败", maxRetries)
}
```

### 2. 频率限制处理

```go
// 带频率控制的API调用
func (ac *AuthorizerClient) CallAPIWithRateLimit(ctx context.Context, apiURL string, params interface{}) (*wego.APIResponse, error) {
    // 检查频率限制
    if !ac.rateLimiter.Allow() {
        return nil, fmt.Errorf("频率限制，请稍后重试")
    }
    
    return ac.CallAPI(ctx, apiURL, params)
}
```

## 最佳实践

### 1. 缓存策略
- 缓存AccessToken减少API调用
- 实现Token自动刷新机制
- 设置合理的缓存过期时间

### 2. 错误处理
- 实现完善的错误日志记录
- 处理网络异常和重试机制
- 监控API调用成功率

### 3. 性能优化
- 使用连接池提高性能
- 实现批量操作减少API调用
- 异步处理耗时操作

## 注意事项

### 1. 权限控制
- 确保第三方平台有相应权限
- 检查授权方的接口权限
- 处理权限不足的错误

### 2. 频率限制
- 遵守微信API调用频率限制
- 实现合理的调用间隔
- 监控调用频率避免被封

### 3. 安全性
- 保护AccessToken不被泄露
- 使用HTTPS加密通信
- 验证API响应签名

通过WeGo库的代调用接口功能，您可以轻松实现各种微信API的代理调用，为授权方提供丰富的功能服务。