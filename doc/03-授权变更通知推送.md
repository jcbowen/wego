# 03-授权变更通知推送

## 概述

授权变更通知推送是微信开放平台在授权状态发生变化时，向第三方平台推送的事件通知。WeGo库提供了完整的事件处理机制，支持多种授权变更事件的接收和处理。

## 事件类型

### 1. 授权成功事件 (authorized)
当公众号/小程序授权给第三方平台时触发。

### 2. 取消授权事件 (unauthorized)  
当公众号/小程序取消授权时触发。

### 3. 授权更新事件 (updateauthorized)
当授权方更新授权时触发。

## 事件推送格式

### XML格式示例

```xml
<!-- 授权成功事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[authorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>

<!-- 取消授权事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[unauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
</xml>

<!-- 授权更新事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[updateauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>
```

## wxopen组件实现

### 事件处理器接口

wxopen组件定义了事件处理器接口，支持自定义事件处理逻辑：

```go
// EventHandler 事件处理器接口
type EventHandler interface {
    // 处理授权成功事件
    HandleAuthorized(event *AuthorizedEvent) error
    
    // 处理取消授权事件  
    HandleUnauthorized(event *UnauthorizedEvent) error
    
    // 处理授权更新事件
    HandleUpdateAuthorized(event *UpdateAuthorizedEvent) error
}

// 默认事件处理器
type DefaultEventHandler struct{}

func (h *DefaultEventHandler) HandleAuthorized(event *AuthorizedEvent) error {
    fmt.Printf("授权成功: AppID=%s, 授权码=%s\n", 
        event.AuthorizerAppid, event.AuthorizationCode)
    
    // 自动获取授权信息并存储
    // ...
    
    return nil
}

func (h *DefaultEventHandler) HandleUnauthorized(event *UnauthorizedEvent) error {
    fmt.Printf("取消授权: AppID=%s\n", event.AuthorizerAppid)
    
    // 清理相关数据
    // ...
    
    return nil
}

func (h *DefaultEventHandler) HandleUpdateAuthorized(event *UpdateAuthorizedEvent) error {
    fmt.Printf("授权更新: AppID=%s, 授权码=%s\n",
        event.AuthorizerAppid, event.AuthorizationCode)
    
    // 更新授权信息
    // ...
    
    return nil
}
```

### 事件处理流程

```go
// 处理授权变更事件
func (client *WxOpenClient) HandleAuthorizationEvent(msg *Message) (*MessageResponse, error) {
    switch msg.InfoType {
    case "authorized":
        event := &AuthorizedEvent{
            AuthorizerAppid:            msg.AuthorizerAppid,
            AuthorizationCode:          msg.AuthorizationCode,
            AuthorizationCodeExpiredTime: msg.AuthorizationCodeExpiredTime,
            PreAuthCode:                msg.PreAuthCode,
        }
        
        if err := client.eventHandler.HandleAuthorized(event); err != nil {
            return nil, fmt.Errorf("处理授权成功事件失败: %v", err)
        }
        
    case "unauthorized":
        event := &UnauthorizedEvent{
            AuthorizerAppid: msg.AuthorizerAppid,
        }
        
        if err := client.eventHandler.HandleUnauthorized(event); err != nil {
            return nil, fmt.Errorf("处理取消授权事件失败: %v", err)
        }
        
    case "updateauthorized":
        event := &UpdateAuthorizedEvent{
            AuthorizerAppid:            msg.AuthorizerAppid,
            AuthorizationCode:          msg.AuthorizationCode,
            AuthorizationCodeExpiredTime: msg.AuthorizationCodeExpiredTime,
            PreAuthCode:                msg.PreAuthCode,
        }
        
        if err := client.eventHandler.HandleUpdateAuthorized(event); err != nil {
            return nil, fmt.Errorf("处理授权更新事件失败: %v", err)
        }
        
    default:
        return nil, fmt.Errorf("未知的事件类型: %s", msg.InfoType)
    }
    
    return &MessageResponse{
        ErrCode: 0,
        ErrMsg:  "ok",
    }, nil
}
```

## 完整示例

### 1. 自定义事件处理器

```go
package main

import (
    "fmt"
    "github.com/jcbowen/wego"
)

// 自定义事件处理器
type MyEventHandler struct {
    db *sql.DB // 假设有数据库连接
}

func (h *MyEventHandler) HandleAuthorized(event *wego.AuthorizedEvent) error {
    fmt.Printf("🎉 新的授权成功: %s\n", event.AuthorizerAppid)
    
    // 1. 使用授权码获取授权信息
    authInfo, err := h.client.QueryAuth(event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取授权信息失败: %v", err)
    }
    
    // 2. 获取授权方详细信息
    authorizerInfo, err := h.client.GetAuthorizerInfo(event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("获取授权方信息失败: %v", err)
    }
    
    // 3. 存储到数据库
    err = h.saveAuthorization(authInfo, authorizerInfo)
    if err != nil {
        return fmt.Errorf("存储授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已保存\n", authorizerInfo.NickName)
    return nil
}

func (h *MyEventHandler) HandleUnauthorized(event *wego.UnauthorizedEvent) error {
    fmt.Printf("⚠️ 取消授权: %s\n", event.AuthorizerAppid)
    
    // 清理相关数据
    err := h.cleanupAuthorization(event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("清理授权数据失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 数据已清理\n", event.AuthorizerAppid)
    return nil
}

func (h *MyEventHandler) HandleUpdateAuthorized(event *wego.UpdateAuthorizedEvent) error {
    fmt.Printf("🔄 授权更新: %s\n", event.AuthorizerAppid)
    
    // 重新获取授权信息
    authInfo, err := h.client.QueryAuth(event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取更新授权信息失败: %v", err)
    }
    
    // 更新数据库中的授权信息
    err = h.updateAuthorization(authInfo)
    if err != nil {
        return fmt.Errorf("更新授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已更新\n", event.AuthorizerAppid)
    return nil
}

// 数据库操作方法（示例）
func (h *MyEventHandler) saveAuthorization(authInfo *wego.AuthorizationInfo, authorizerInfo *wego.AuthorizerInfo) error {
    // 实现数据库存储逻辑
    return nil
}

func (h *MyEventHandler) cleanupAuthorization(appID string) error {
    // 实现数据清理逻辑
    return nil
}

func (h *MyEventHandler) updateAuthorization(authInfo *wego.AuthorizationInfo) error {
    // 实现数据更新逻辑
    return nil
}
```

### 2. 集成到HTTP服务器

```go
func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // 设置自定义事件处理器
    eventHandler := &MyEventHandler{db: yourDB}
    client.SetEventHandler(eventHandler)
    
    // HTTP消息处理
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        // 验证签名和解析消息
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        body, _ := io.ReadAll(r.Body)
        msg, err := client.DecryptMessage(string(body), signature, timestamp, nonce)
        if err != nil {
            http.Error(w, "消息处理失败", http.StatusBadRequest)
            return
        }
        
        // 处理不同类型的消息
        var response *wego.MessageResponse
        
        switch msg.InfoType {
        case "authorized", "unauthorized", "updateauthorized":
            response, err = client.HandleAuthorizationEvent(msg)
            
        case "component_verify_ticket":
            response, err = client.HandleVerifyTicket(msg)
            
        default:
            fmt.Printf("收到未知消息类型: %s\n", msg.InfoType)
            response = &wego.MessageResponse{ErrCode: 0, ErrMsg: "ok"}
        }
        
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(response.ToXML()))
    })
    
    http.ListenAndServe(":8080", nil)
}
```

## 事件处理最佳实践

### 1. 幂等性处理
确保事件处理是幂等的，避免重复处理导致数据不一致。

### 2. 异步处理
对于耗时的操作（如数据库操作、API调用），建议使用异步处理。

### 3. 错误处理
实现完善的错误处理机制，记录错误日志，确保服务稳定性。

### 4. 监控告警
设置监控告警，及时发现和处理事件处理异常。

## 注意事项

### 1. 消息验证
- 始终验证消息签名
- 检查时间戳防止重放攻击
- 验证AppID匹配

### 2. 响应要求
- 必须在5秒内返回响应
- 响应格式必须正确
- 错误时返回适当的错误码

### 3. 数据一致性
- 确保事件处理的数据一致性
- 实现事务处理机制
- 处理并发事件

## 常见问题

### Q: 收不到授权变更事件
A: 检查服务器配置、网络连接、消息签名验证

### Q: 事件处理超时
A: 优化处理逻辑，实现异步处理，确保5秒内响应

### Q: 重复事件处理
A: 实现幂等性处理，检查事件ID或时间戳

## 相关API

- `HandleAuthorizationEvent()` - 处理授权变更事件
- `SetEventHandler()` - 设置自定义事件处理器
- `QueryAuth()` - 使用授权码获取授权信息
- `GetAuthorizerInfo()` - 获取授权方详细信息

通过wxopen组件，您可以轻松处理各种授权变更事件，确保第三方平台服务的稳定运行。