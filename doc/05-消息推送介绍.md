# 05-消息推送介绍

## 概述

消息推送是微信开放平台向第三方平台推送各种事件和消息的机制。wego组件提供了完整的消息接收、解析和处理功能，支持多种消息类型的处理。

## 消息类型

### 1. 事件推送
- 授权变更事件（authorized/unauthorized/updateauthorized）
- 票据推送事件（component_verify_ticket）
- 其他业务事件

### 2. 用户消息推送
- 文本消息
- 图片消息
- 语音消息
- 视频消息
- 地理位置消息
- 链接消息

### 3. 菜单事件
- 点击菜单事件
- 扫码推事件
- 扫码推事件且弹出"消息接收中"提示框
- 弹出系统拍照发图事件
- 弹出拍照或者相册发图事件
- 弹出微信相册发图事件
- 弹出地理位置选择器事件

## 消息推送流程

### 1. 消息接收
微信服务器向第三方平台配置的URL推送加密消息。

### 2. 消息验证
验证消息签名，确保消息来源可信。

### 3. 消息解密
使用EncodingAESKey解密消息内容。

### 4. 消息处理
根据消息类型调用相应的处理器。

### 5. 响应返回
在5秒内返回处理结果。

## wego组件实现

### 消息处理器接口

```go
// MessageHandler 消息处理器接口
type MessageHandler interface {
    // 处理文本消息
    HandleTextMessage(msg *TextMessage) (*MessageResponse, error)
    
    // 处理图片消息
    HandleImageMessage(msg *ImageMessage) (*MessageResponse, error)
    
    // 处理语音消息
    HandleVoiceMessage(msg *VoiceMessage) (*MessageResponse, error)
    
    // 处理视频消息
    HandleVideoMessage(msg *VideoMessage) (*MessageResponse, error)
    
    // 处理地理位置消息
    HandleLocationMessage(msg *LocationMessage) (*MessageResponse, error)
    
    // 处理链接消息
    HandleLinkMessage(msg *LinkMessage) (*MessageResponse, error)
    
    // 处理菜单点击事件
    HandleMenuClickEvent(msg *MenuClickEvent) (*MessageResponse, error)
    
    // 处理菜单扫码事件
    HandleMenuScanEvent(msg *MenuScanEvent) (*MessageResponse, error)
}

// 默认消息处理器
type DefaultMessageHandler struct{}

func (h *DefaultMessageHandler) HandleTextMessage(msg *TextMessage) (*MessageResponse, error) {
    fmt.Printf("收到文本消息: %s\n", msg.Content)
    
    // 返回文本回复
    return &MessageResponse{
        MsgType: "text",
        Content: "收到您的消息: " + msg.Content,
    }, nil
}

// 其他消息处理方法类似...
```

### 消息处理流程

```go
// 处理推送消息
func (client *WxOpenClient) HandlePushMessage(msg *Message) (*MessageResponse, error) {
    // 根据MsgType和Event类型分发处理
    switch msg.MsgType {
    case "text":
        return client.messageHandler.HandleTextMessage(&TextMessage{
            Message: msg,
            Content: msg.Content,
        })
        
    case "image":
        return client.messageHandler.HandleImageMessage(&ImageMessage{
            Message: msg,
            PicUrl:  msg.PicUrl,
        })
        
    case "event":
        return client.HandleEventMessage(msg)
        
    default:
        return &MessageResponse{
            ErrCode: 0,
            ErrMsg:  "ok",
        }, nil
    }
}

// 处理事件消息
func (client *WxOpenClient) HandleEventMessage(msg *Message) (*MessageResponse, error) {
    switch msg.Event {
    case "subscribe":
        // 处理关注事件
        return client.messageHandler.HandleSubscribeEvent(&SubscribeEvent{
            Message: msg,
        })
        
    case "unsubscribe":
        // 处理取消关注事件
        return client.messageHandler.HandleUnsubscribeEvent(&UnsubscribeEvent{
            Message: msg,
        })
        
    case "CLICK":
        // 处理菜单点击事件
        return client.messageHandler.HandleMenuClickEvent(&MenuClickEvent{
            Message: msg,
            EventKey: msg.EventKey,
        })
        
    // 其他事件类型...
        
    default:
        return &MessageResponse{
            ErrCode: 0,
            ErrMsg:  "ok",
        }, nil
    }
}
```

## 完整示例

### 1. 自定义消息处理器

```go
package main

import (
    "fmt"
    "github.com/jcbowen/jcbaseGo/component/wego"
)

// 自定义消息处理器
type MyMessageHandler struct {
    db *sql.DB // 数据库连接
}

func (h *MyMessageHandler) HandleTextMessage(msg *wego.TextMessage) (*wego.MessageResponse, error) {
    fmt.Printf("📝 收到文本消息 From: %s, Content: %s\n", msg.FromUserName, msg.Content)
    
    // 保存消息到数据库
    err := h.saveMessage(msg)
    if err != nil {
        return nil, fmt.Errorf("保存消息失败: %v", err)
    }
    
    // 根据内容回复
    var reply string
    switch msg.Content {
    case "帮助":
        reply = "欢迎使用！请输入以下关键词：\n1. 帮助 - 查看帮助信息\n2. 天气 - 查询天气\n3. 新闻 - 查看最新新闻"
    case "天气":
        reply = "今天天气晴朗，温度25°C，适合外出活动"
    case "新闻":
        reply = "今日头条：科技创新推动经济发展"
    default:
        reply = "收到您的消息：" + msg.Content + "\n请输入'帮助'查看可用功能"
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: reply,
    }, nil
}

func (h *MyMessageHandler) HandleImageMessage(msg *wego.ImageMessage) (*wego.MessageResponse, error) {
    fmt.Printf("🖼️ 收到图片消息 From: %s, PicUrl: %s\n", msg.FromUserName, msg.PicUrl)
    
    // 保存图片信息
    err := h.saveImageMessage(msg)
    if err != nil {
        return nil, fmt.Errorf("保存图片消息失败: %v", err)
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: "收到您的图片，已保存！",
    }, nil
}

func (h *MyMessageHandler) HandleSubscribeEvent(msg *wego.SubscribeEvent) (*wego.MessageResponse, error) {
    fmt.Printf("🎉 用户关注: %s\n", msg.FromUserName)
    
    // 记录关注事件
    err := h.recordSubscribe(msg.FromUserName)
    if err != nil {
        return nil, fmt.Errorf("记录关注事件失败: %v", err)
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: "欢迎关注！感谢您的支持！",
    }, nil
}

func (h *MyMessageHandler) HandleMenuClickEvent(msg *wego.MenuClickEvent) (*wego.MessageResponse, error) {
    fmt.Printf("📱 菜单点击: %s, EventKey: %s\n", msg.FromUserName, msg.EventKey)
    
    var reply string
    switch msg.EventKey {
    case "V1001_TODAY_MUSIC":
        reply = "今日推荐音乐：周杰伦 - 晴天"
    case "V1001_GOOD":
        reply = "感谢您的点赞！"
    default:
        reply = "点击了菜单：" + msg.EventKey
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: reply,
    }, nil
}

// 数据库操作方法
func (h *MyMessageHandler) saveMessage(msg *wego.TextMessage) error {
    // 实现消息保存逻辑
    return nil
}

func (h *MyMessageHandler) saveImageMessage(msg *wego.ImageMessage) error {
    // 实现图片消息保存逻辑
    return nil
}

func (h *MyMessageHandler) recordSubscribe(openID string) error {
    // 实现关注记录逻辑
    return nil
}
```

### 2. HTTP服务器集成

```go
func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // 设置自定义消息处理器
    db, _ := sql.Open("mysql", "user:pass@/dbname")
    messageHandler := &MyMessageHandler{db: db}
    client.SetMessageHandler(messageHandler)
    
    // HTTP消息处理
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        // 验证签名
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        // 读取请求体
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "读取请求体失败", http.StatusBadRequest)
            return
        }
        
        // 验证URL（首次配置时）
        if r.URL.Query().Get("echostr") != "" {
            echostr := r.URL.Query().Get("echostr")
            decryptedEchostr, err := client.VerifyURL(signature, timestamp, nonce, echostr)
            if err != nil {
                http.Error(w, "URL验证失败", http.StatusBadRequest)
                return
            }
            w.Write([]byte(decryptedEchostr))
            return
        }
        
        // 解密消息
        msg, err := client.DecryptMessage(string(body), signature, timestamp, nonce)
        if err != nil {
            http.Error(w, "消息解密失败", http.StatusBadRequest)
            return
        }
        
        // 处理消息
        response, err := client.HandlePushMessage(msg)
        if err != nil {
            http.Error(w, "消息处理失败", http.StatusInternalServerError)
            return
        }
        
        // 加密响应
        encryptedResponse, err := client.EncryptMessage(response.ToXML())
        if err != nil {
            http.Error(w, "响应加密失败", http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(encryptedResponse))
    })
    
    fmt.Println("消息推送服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

## 消息处理最佳实践

### 1. 响应时间控制
- 确保在5秒内返回响应
- 对于耗时操作，先返回"success"，再异步处理
- 实现超时控制机制

### 2. 消息去重
- 检查MsgID防止重复处理
- 实现消息幂等性处理
- 记录已处理消息ID

### 3. 错误处理
- 完善的错误日志记录
- 优雅的错误恢复机制
- 监控消息处理成功率

### 4. 性能优化
- 使用连接池处理数据库操作
- 实现消息队列异步处理
- 缓存常用数据减少数据库查询

## 注意事项

### 1. 安全性
- 始终验证消息签名
- 使用HTTPS保护数据传输
- 定期更换EncodingAESKey

### 2. 可靠性
- 实现消息持久化存储
- 处理网络异常和重试
- 监控服务可用性

### 3. 兼容性
- 支持多种消息格式
- 处理未知消息类型
- 保持向后兼容

## 常见问题

### Q: 消息解密失败
A: 检查EncodingAESKey是否正确、消息格式是否标准

### Q: 响应超时
A: 优化处理逻辑、实现异步处理、检查网络延迟

### Q: 重复消息处理
A: 实现MsgID检查、设置消息去重机制

## 相关API

- `HandlePushMessage()` - 处理推送消息
- `DecryptMessage()` - 解密消息
- `EncryptMessage()` - 加密响应
- `VerifyURL()` - 验证URL
- `SetMessageHandler()` - 设置自定义消息处理器

通过wxopen组件，您可以轻松处理各种微信消息推送，构建功能丰富的第三方平台应用。