# 05-æ¶ˆæ¯æ¨é€ä»‹ç»

## æ¦‚è¿°

æ¶ˆæ¯æ¨é€æ˜¯å¾®ä¿¡å¼€æ”¾å¹³å°å‘ç¬¬ä¸‰æ–¹å¹³å°æ¨é€å„ç§äº‹ä»¶å’Œæ¶ˆæ¯çš„æœºåˆ¶ã€‚wegoç»„ä»¶æä¾›äº†å®Œæ•´çš„æ¶ˆæ¯æ¥æ”¶ã€è§£æå’Œå¤„ç†åŠŸèƒ½ï¼Œæ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹çš„å¤„ç†ã€‚

## æ¶ˆæ¯ç±»å‹

### 1. äº‹ä»¶æ¨é€
- æˆæƒå˜æ›´äº‹ä»¶ï¼ˆauthorized/unauthorized/updateauthorizedï¼‰
- ç¥¨æ®æ¨é€äº‹ä»¶ï¼ˆcomponent_verify_ticketï¼‰
- å…¶ä»–ä¸šåŠ¡äº‹ä»¶

### 2. ç”¨æˆ·æ¶ˆæ¯æ¨é€
- æ–‡æœ¬æ¶ˆæ¯
- å›¾ç‰‡æ¶ˆæ¯
- è¯­éŸ³æ¶ˆæ¯
- è§†é¢‘æ¶ˆæ¯
- åœ°ç†ä½ç½®æ¶ˆæ¯
- é“¾æ¥æ¶ˆæ¯

### 3. èœå•äº‹ä»¶
- ç‚¹å‡»èœå•äº‹ä»¶
- æ‰«ç æ¨äº‹ä»¶
- æ‰«ç æ¨äº‹ä»¶ä¸”å¼¹å‡º"æ¶ˆæ¯æ¥æ”¶ä¸­"æç¤ºæ¡†
- å¼¹å‡ºç³»ç»Ÿæ‹ç…§å‘å›¾äº‹ä»¶
- å¼¹å‡ºæ‹ç…§æˆ–è€…ç›¸å†Œå‘å›¾äº‹ä»¶
- å¼¹å‡ºå¾®ä¿¡ç›¸å†Œå‘å›¾äº‹ä»¶
- å¼¹å‡ºåœ°ç†ä½ç½®é€‰æ‹©å™¨äº‹ä»¶

## æ¶ˆæ¯æ¨é€æµç¨‹

### 1. æ¶ˆæ¯æ¥æ”¶
å¾®ä¿¡æœåŠ¡å™¨å‘ç¬¬ä¸‰æ–¹å¹³å°é…ç½®çš„URLæ¨é€åŠ å¯†æ¶ˆæ¯ã€‚

### 2. æ¶ˆæ¯éªŒè¯
éªŒè¯æ¶ˆæ¯ç­¾åï¼Œç¡®ä¿æ¶ˆæ¯æ¥æºå¯ä¿¡ã€‚

### 3. æ¶ˆæ¯è§£å¯†
ä½¿ç”¨EncodingAESKeyè§£å¯†æ¶ˆæ¯å†…å®¹ã€‚

### 4. æ¶ˆæ¯å¤„ç†
æ ¹æ®æ¶ˆæ¯ç±»å‹è°ƒç”¨ç›¸åº”çš„å¤„ç†å™¨ã€‚

### 5. å“åº”è¿”å›
åœ¨5ç§’å†…è¿”å›å¤„ç†ç»“æœã€‚

## wegoç»„ä»¶å®ç°

### æ¶ˆæ¯å¤„ç†å™¨æ¥å£

```go
// MessageHandler æ¶ˆæ¯å¤„ç†å™¨æ¥å£
type MessageHandler interface {
    // å¤„ç†æ–‡æœ¬æ¶ˆæ¯
    HandleTextMessage(msg *TextMessage) (*MessageResponse, error)
    
    // å¤„ç†å›¾ç‰‡æ¶ˆæ¯
    HandleImageMessage(msg *ImageMessage) (*MessageResponse, error)
    
    // å¤„ç†è¯­éŸ³æ¶ˆæ¯
    HandleVoiceMessage(msg *VoiceMessage) (*MessageResponse, error)
    
    // å¤„ç†è§†é¢‘æ¶ˆæ¯
    HandleVideoMessage(msg *VideoMessage) (*MessageResponse, error)
    
    // å¤„ç†åœ°ç†ä½ç½®æ¶ˆæ¯
    HandleLocationMessage(msg *LocationMessage) (*MessageResponse, error)
    
    // å¤„ç†é“¾æ¥æ¶ˆæ¯
    HandleLinkMessage(msg *LinkMessage) (*MessageResponse, error)
    
    // å¤„ç†èœå•ç‚¹å‡»äº‹ä»¶
    HandleMenuClickEvent(msg *MenuClickEvent) (*MessageResponse, error)
    
    // å¤„ç†èœå•æ‰«ç äº‹ä»¶
    HandleMenuScanEvent(msg *MenuScanEvent) (*MessageResponse, error)
}

// é»˜è®¤æ¶ˆæ¯å¤„ç†å™¨
type DefaultMessageHandler struct{}

func (h *DefaultMessageHandler) HandleTextMessage(msg *TextMessage) (*MessageResponse, error) {
    fmt.Printf("æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯: %s\n", msg.Content)
    
    // è¿”å›æ–‡æœ¬å›å¤
    return &MessageResponse{
        MsgType: "text",
        Content: "æ”¶åˆ°æ‚¨çš„æ¶ˆæ¯: " + msg.Content,
    }, nil
}

// å…¶ä»–æ¶ˆæ¯å¤„ç†æ–¹æ³•ç±»ä¼¼...
```

### æ¶ˆæ¯å¤„ç†æµç¨‹

```go
// å¤„ç†æ¨é€æ¶ˆæ¯
func (client *WxOpenClient) HandlePushMessage(msg *Message) (*MessageResponse, error) {
    // æ ¹æ®MsgTypeå’ŒEventç±»å‹åˆ†å‘å¤„ç†
    switch msg.MsgType {
    case "text":
        return client.messageHandler.HandleTextMessage(&TextMessage{
            Message: msg,
            Content: msg.Content,
        })
        
    case "image":
        return client.messageHandler.HandleImageMessage(&ImageMessage{
            Message: msg,
            PicUrl:  msg.PicUrl,
        })
        
    case "event":
        return client.HandleEventMessage(msg)
        
    default:
        return &MessageResponse{
            ErrCode: 0,
            ErrMsg:  "ok",
        }, nil
    }
}

// å¤„ç†äº‹ä»¶æ¶ˆæ¯
func (client *WxOpenClient) HandleEventMessage(msg *Message) (*MessageResponse, error) {
    switch msg.Event {
    case "subscribe":
        // å¤„ç†å…³æ³¨äº‹ä»¶
        return client.messageHandler.HandleSubscribeEvent(&SubscribeEvent{
            Message: msg,
        })
        
    case "unsubscribe":
        // å¤„ç†å–æ¶ˆå…³æ³¨äº‹ä»¶
        return client.messageHandler.HandleUnsubscribeEvent(&UnsubscribeEvent{
            Message: msg,
        })
        
    case "CLICK":
        // å¤„ç†èœå•ç‚¹å‡»äº‹ä»¶
        return client.messageHandler.HandleMenuClickEvent(&MenuClickEvent{
            Message: msg,
            EventKey: msg.EventKey,
        })
        
    // å…¶ä»–äº‹ä»¶ç±»å‹...
        
    default:
        return &MessageResponse{
            ErrCode: 0,
            ErrMsg:  "ok",
        }, nil
    }
}
```

## å®Œæ•´ç¤ºä¾‹

### 1. è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨

```go
package main

import (
    "fmt"
    "github.com/jcbowen/jcbaseGo/component/wego"
)

// è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨
type MyMessageHandler struct {
    db *sql.DB // æ•°æ®åº“è¿æ¥
}

func (h *MyMessageHandler) HandleTextMessage(msg *wego.TextMessage) (*wego.MessageResponse, error) {
    fmt.Printf("ğŸ“ æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯ From: %s, Content: %s\n", msg.FromUserName, msg.Content)
    
    // ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
    err := h.saveMessage(msg)
    if err != nil {
        return nil, fmt.Errorf("ä¿å­˜æ¶ˆæ¯å¤±è´¥: %v", err)
    }
    
    // æ ¹æ®å†…å®¹å›å¤
    var reply string
    switch msg.Content {
    case "å¸®åŠ©":
        reply = "æ¬¢è¿ä½¿ç”¨ï¼è¯·è¾“å…¥ä»¥ä¸‹å…³é”®è¯ï¼š\n1. å¸®åŠ© - æŸ¥çœ‹å¸®åŠ©ä¿¡æ¯\n2. å¤©æ°” - æŸ¥è¯¢å¤©æ°”\n3. æ–°é—» - æŸ¥çœ‹æœ€æ–°æ–°é—»"
    case "å¤©æ°”":
        reply = "ä»Šå¤©å¤©æ°”æ™´æœ—ï¼Œæ¸©åº¦25Â°Cï¼Œé€‚åˆå¤–å‡ºæ´»åŠ¨"
    case "æ–°é—»":
        reply = "ä»Šæ—¥å¤´æ¡ï¼šç§‘æŠ€åˆ›æ–°æ¨åŠ¨ç»æµå‘å±•"
    default:
        reply = "æ”¶åˆ°æ‚¨çš„æ¶ˆæ¯ï¼š" + msg.Content + "\nè¯·è¾“å…¥'å¸®åŠ©'æŸ¥çœ‹å¯ç”¨åŠŸèƒ½"
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: reply,
    }, nil
}

func (h *MyMessageHandler) HandleImageMessage(msg *wego.ImageMessage) (*wego.MessageResponse, error) {
    fmt.Printf("ğŸ–¼ï¸ æ”¶åˆ°å›¾ç‰‡æ¶ˆæ¯ From: %s, PicUrl: %s\n", msg.FromUserName, msg.PicUrl)
    
    // ä¿å­˜å›¾ç‰‡ä¿¡æ¯
    err := h.saveImageMessage(msg)
    if err != nil {
        return nil, fmt.Errorf("ä¿å­˜å›¾ç‰‡æ¶ˆæ¯å¤±è´¥: %v", err)
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: "æ”¶åˆ°æ‚¨çš„å›¾ç‰‡ï¼Œå·²ä¿å­˜ï¼",
    }, nil
}

func (h *MyMessageHandler) HandleSubscribeEvent(msg *wego.SubscribeEvent) (*wego.MessageResponse, error) {
    fmt.Printf("ğŸ‰ ç”¨æˆ·å…³æ³¨: %s\n", msg.FromUserName)
    
    // è®°å½•å…³æ³¨äº‹ä»¶
    err := h.recordSubscribe(msg.FromUserName)
    if err != nil {
        return nil, fmt.Errorf("è®°å½•å…³æ³¨äº‹ä»¶å¤±è´¥: %v", err)
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: "æ¬¢è¿å…³æ³¨ï¼æ„Ÿè°¢æ‚¨çš„æ”¯æŒï¼",
    }, nil
}

func (h *MyMessageHandler) HandleMenuClickEvent(msg *wego.MenuClickEvent) (*wego.MessageResponse, error) {
    fmt.Printf("ğŸ“± èœå•ç‚¹å‡»: %s, EventKey: %s\n", msg.FromUserName, msg.EventKey)
    
    var reply string
    switch msg.EventKey {
    case "V1001_TODAY_MUSIC":
        reply = "ä»Šæ—¥æ¨èéŸ³ä¹ï¼šå‘¨æ°ä¼¦ - æ™´å¤©"
    case "V1001_GOOD":
        reply = "æ„Ÿè°¢æ‚¨çš„ç‚¹èµï¼"
    default:
        reply = "ç‚¹å‡»äº†èœå•ï¼š" + msg.EventKey
    }
    
    return &wego.MessageResponse{
        MsgType: "text",
        Content: reply,
    }, nil
}

// æ•°æ®åº“æ“ä½œæ–¹æ³•
func (h *MyMessageHandler) saveMessage(msg *wego.TextMessage) error {
    // å®ç°æ¶ˆæ¯ä¿å­˜é€»è¾‘
    return nil
}

func (h *MyMessageHandler) saveImageMessage(msg *wego.ImageMessage) error {
    // å®ç°å›¾ç‰‡æ¶ˆæ¯ä¿å­˜é€»è¾‘
    return nil
}

func (h *MyMessageHandler) recordSubscribe(openID string) error {
    // å®ç°å…³æ³¨è®°å½•é€»è¾‘
    return nil
}
```

### 2. HTTPæœåŠ¡å™¨é›†æˆ

```go
func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // è®¾ç½®è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨
    db, _ := sql.Open("mysql", "user:pass@/dbname")
    messageHandler := &MyMessageHandler{db: db}
    client.SetMessageHandler(messageHandler)
    
    // HTTPæ¶ˆæ¯å¤„ç†
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        // éªŒè¯ç­¾å
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        // è¯»å–è¯·æ±‚ä½“
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "è¯»å–è¯·æ±‚ä½“å¤±è´¥", http.StatusBadRequest)
            return
        }
        
        // éªŒè¯URLï¼ˆé¦–æ¬¡é…ç½®æ—¶ï¼‰
        if r.URL.Query().Get("echostr") != "" {
            echostr := r.URL.Query().Get("echostr")
            decryptedEchostr, err := client.VerifyURL(signature, timestamp, nonce, echostr)
            if err != nil {
                http.Error(w, "URLéªŒè¯å¤±è´¥", http.StatusBadRequest)
                return
            }
            w.Write([]byte(decryptedEchostr))
            return
        }
        
        // è§£å¯†æ¶ˆæ¯
        msg, err := client.DecryptMessage(string(body), signature, timestamp, nonce)
        if err != nil {
            http.Error(w, "æ¶ˆæ¯è§£å¯†å¤±è´¥", http.StatusBadRequest)
            return
        }
        
        // å¤„ç†æ¶ˆæ¯
        response, err := client.HandlePushMessage(msg)
        if err != nil {
            http.Error(w, "æ¶ˆæ¯å¤„ç†å¤±è´¥", http.StatusInternalServerError)
            return
        }
        
        // åŠ å¯†å“åº”
        encryptedResponse, err := client.EncryptMessage(response.ToXML())
        if err != nil {
            http.Error(w, "å“åº”åŠ å¯†å¤±è´¥", http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(encryptedResponse))
    })
    
    fmt.Println("æ¶ˆæ¯æ¨é€æœåŠ¡å¯åŠ¨åœ¨ :8080")
    http.ListenAndServe(":8080", nil)
}
```

## æ¶ˆæ¯å¤„ç†æœ€ä½³å®è·µ

### 1. å“åº”æ—¶é—´æ§åˆ¶
- ç¡®ä¿åœ¨5ç§’å†…è¿”å›å“åº”
- å¯¹äºè€—æ—¶æ“ä½œï¼Œå…ˆè¿”å›"success"ï¼Œå†å¼‚æ­¥å¤„ç†
- å®ç°è¶…æ—¶æ§åˆ¶æœºåˆ¶

### 2. æ¶ˆæ¯å»é‡
- æ£€æŸ¥MsgIDé˜²æ­¢é‡å¤å¤„ç†
- å®ç°æ¶ˆæ¯å¹‚ç­‰æ€§å¤„ç†
- è®°å½•å·²å¤„ç†æ¶ˆæ¯ID

### 3. é”™è¯¯å¤„ç†
- å®Œå–„çš„é”™è¯¯æ—¥å¿—è®°å½•
- ä¼˜é›…çš„é”™è¯¯æ¢å¤æœºåˆ¶
- ç›‘æ§æ¶ˆæ¯å¤„ç†æˆåŠŸç‡

### 4. æ€§èƒ½ä¼˜åŒ–
- ä½¿ç”¨è¿æ¥æ± å¤„ç†æ•°æ®åº“æ“ä½œ
- å®ç°æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥å¤„ç†
- ç¼“å­˜å¸¸ç”¨æ•°æ®å‡å°‘æ•°æ®åº“æŸ¥è¯¢

## æ³¨æ„äº‹é¡¹

### 1. å®‰å…¨æ€§
- å§‹ç»ˆéªŒè¯æ¶ˆæ¯ç­¾å
- ä½¿ç”¨HTTPSä¿æŠ¤æ•°æ®ä¼ è¾“
- å®šæœŸæ›´æ¢EncodingAESKey

### 2. å¯é æ€§
- å®ç°æ¶ˆæ¯æŒä¹…åŒ–å­˜å‚¨
- å¤„ç†ç½‘ç»œå¼‚å¸¸å’Œé‡è¯•
- ç›‘æ§æœåŠ¡å¯ç”¨æ€§

### 3. å…¼å®¹æ€§
- æ”¯æŒå¤šç§æ¶ˆæ¯æ ¼å¼
- å¤„ç†æœªçŸ¥æ¶ˆæ¯ç±»å‹
- ä¿æŒå‘åå…¼å®¹

## å¸¸è§é—®é¢˜

### Q: æ¶ˆæ¯è§£å¯†å¤±è´¥
A: æ£€æŸ¥EncodingAESKeyæ˜¯å¦æ­£ç¡®ã€æ¶ˆæ¯æ ¼å¼æ˜¯å¦æ ‡å‡†

### Q: å“åº”è¶…æ—¶
A: ä¼˜åŒ–å¤„ç†é€»è¾‘ã€å®ç°å¼‚æ­¥å¤„ç†ã€æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ

### Q: é‡å¤æ¶ˆæ¯å¤„ç†
A: å®ç°MsgIDæ£€æŸ¥ã€è®¾ç½®æ¶ˆæ¯å»é‡æœºåˆ¶

## ç›¸å…³API

- `HandlePushMessage()` - å¤„ç†æ¨é€æ¶ˆæ¯
- `DecryptMessage()` - è§£å¯†æ¶ˆæ¯
- `EncryptMessage()` - åŠ å¯†å“åº”
- `VerifyURL()` - éªŒè¯URL
- `SetMessageHandler()` - è®¾ç½®è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å™¨

é€šè¿‡wxopenç»„ä»¶ï¼Œæ‚¨å¯ä»¥è½»æ¾å¤„ç†å„ç§å¾®ä¿¡æ¶ˆæ¯æ¨é€ï¼Œæ„å»ºåŠŸèƒ½ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹å¹³å°åº”ç”¨ã€‚