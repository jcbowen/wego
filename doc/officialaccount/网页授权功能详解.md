# 微信公众号网页授权功能详解

## 概述

微信公众号网页授权是微信OAuth2.0授权机制在公众号场景下的实现，允许第三方网页通过微信授权获取用户基本信息。WeGo库提供了完整的网页授权实现，支持授权码模式和静默授权模式。

## 授权流程

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/service/guide/h5/auth.html" index="0">0</mcreference>，微信公众号网页授权流程分为以下步骤：

### 第一步：引导用户进入授权页面
引导用户访问授权页面，用户同意授权后，微信会重定向到指定的redirect_uri并携带code参数。

### 第二步：通过code换取access_token
使用授权码code换取网页授权access_token。

### 第三步：刷新access_token（如果需要）
由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新。

### 第四步：拉取用户信息（需授权作用域为snsapi_userinfo）
如果网页授权作用域为snsapi_userinfo，此时可以通过access_token和openid拉取用户信息。

### 授权作用域说明
- **snsapi_base**：静默授权，不弹出授权页面，只能获取用户的openid
- **snsapi_userinfo**：弹出授权页面，可通过openid获取用户基本信息

## 开发前必读

### 1. 适用账号
网页授权仅支持已认证的服务号，其他类型的账号（公众号/小程序/网站应用/移动应用等除了已认证服务号之外的账号）均不支持使用微信网页授权登录功能。

### 2. 网页授权回调域名
在微信服务号请求用户网页授权之前，开发者需要先到公众平台中的「设置与开发 - 账号设置 - 功能设置」的配置选项中，修改「网页授权域名」。

**注意事项：**
- 这里填写的是域名（例如：www.qq.com），而不是URL，因此请勿加 http:// 等协议头
- 授权回调域名配置规范为全域名
- 如果服务号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方平台代替服务号实现网页授权即可

### 3. UnionId机制
网页授权获取用户基本信息遵循UnionID机制。如果开发者有在多个服务号，或在服务号、移动应用、小程序等之间统一用户账号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定服务号后，才可利用UnionId机制来满足上述需求。

## 代码实现

### OAuth客户端初始化

```go
package main

import (
    "context"
    "fmt"
    "github.com/jcbowen/wego/official_account"
)

func main() {
    // 创建公众号客户端配置
    config := &official_account.Config{
        AppID:     "your_app_id",
        AppSecret: "your_app_secret",
        Token:     "your_token",
        EncodingAESKey: "your_encoding_aes_key",
    }
    
    // 创建公众号客户端
    client := official_account.NewClient(config)
    
    // 创建OAuth客户端
    oauthClient := official_account.NewOAuthClient(client)
}
```

### 生成授权URL

```go
// GenerateAuthorizeURL 生成网页授权URL
// @param ctx 上下文
// @param req 授权请求参数
// @return 授权URL
// @return 错误信息
func (o *OAuthClient) GenerateAuthorizeURL(ctx context.Context, req *OAuthAuthorizeRequest) (string, error)

// 使用示例
func generateAuthURL(oauthClient *official_account.OAuthClient) {
    ctx := context.Background()
    
    req := &official_account.OAuthAuthorizeRequest{
        AppID:       "your_app_id",
        RedirectURI: "https://yourdomain.com/oauth/callback",
        Scope:       core.OAuthScopeUserInfo, // 或 core.OAuthScopeBase
        State:       "your_state_parameter",
    }
    
    authURL, err := oauthClient.GenerateAuthorizeURL(ctx, req)
    if err != nil {
        fmt.Printf("生成授权URL失败: %v\n", err)
        return
    }
    
    fmt.Printf("授权URL: %s\n", authURL)
}
```

### 获取AccessToken

```go
// GetAccessToken 通过code获取网页授权access_token
// @param ctx 上下文
// @param code 授权码
// @return 授权响应
// @return 错误信息
func (o *OAuthClient) GetAccessToken(ctx context.Context, code string) (*OAuthAccessTokenResponse, error)

// 使用示例
func getAccessToken(oauthClient *official_account.OAuthClient, code string) {
    ctx := context.Background()
    
    tokenResp, err := oauthClient.GetAccessToken(ctx, code)
    if err != nil {
        fmt.Printf("获取AccessToken失败: %v\n", err)
        return
    }
    
    fmt.Printf("AccessToken: %s\n", tokenResp.AccessToken)
    fmt.Printf("OpenID: %s\n", tokenResp.OpenID)
    fmt.Printf("有效期: %d秒\n", tokenResp.ExpiresIn)
}
```

### 获取用户信息

```go
// GetUserInfo 获取用户信息
// @param ctx 上下文
// @param accessToken 网页授权access_token
// @param openID 用户openid
// @param lang 语言，默认为zh_CN
// @return 用户信息
// @return 错误信息
func (o *OAuthClient) GetUserInfo(ctx context.Context, accessToken, openID, lang string) (*OAuthUserInfoResponse, error)

// 使用示例
func getUserInfo(oauthClient *official_account.OAuthClient, accessToken, openID string) {
    ctx := context.Background()
    
    userInfo, err := oauthClient.GetUserInfo(ctx, accessToken, openID, "zh_CN")
    if err != nil {
        fmt.Printf("获取用户信息失败: %v\n", err)
        return
    }
    
    fmt.Printf("昵称: %s\n", userInfo.Nickname)
    fmt.Printf("头像: %s\n", userInfo.HeadImgURL)
    fmt.Printf("性别: %d\n", userInfo.Sex)
    fmt.Printf("城市: %s\n", userInfo.City)
}
```

### 刷新AccessToken

```go
// RefreshAccessToken 刷新网页授权access_token
// @param ctx 上下文
// @param refreshToken 刷新token
// @return 授权响应
// @return 错误信息
func (o *OAuthClient) RefreshAccessToken(ctx context.Context, refreshToken string) (*OAuthAccessTokenResponse, error)

// 使用示例
func refreshToken(oauthClient *official_account.OAuthClient, refreshToken string) {
    ctx := context.Background()
    
    newToken, err := oauthClient.RefreshAccessToken(ctx, refreshToken)
    if err != nil {
        fmt.Printf("刷新Token失败: %v\n", err)
        return
    }
    
    fmt.Printf("新的AccessToken: %s\n", newToken.AccessToken)
    fmt.Printf("新的RefreshToken: %s\n", newToken.RefreshToken)
}
```

### 验证AccessToken有效性

```go
// ValidateAccessToken 检验授权凭证（access_token）是否有效
// @param ctx 上下文
// @param accessToken 网页授权access_token
// @param openID 用户openid
// @return 是否有效
// @return 错误信息
func (o *OAuthClient) ValidateAccessToken(ctx context.Context, accessToken, openID string) (bool, error)

// 使用示例
func validateToken(oauthClient *official_account.OAuthClient, accessToken, openID string) {
    ctx := context.Background()
    
    isValid, err := oauthClient.ValidateAccessToken(ctx, accessToken, openID)
    if err != nil {
        fmt.Printf("验证Token失败: %v\n", err)
        return
    }
    
    if isValid {
        fmt.Println("Token有效")
    } else {
        fmt.Println("Token无效")
    }
}
```

## 完整示例

### HTTP服务器完整示例

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "github.com/jcbowen/wego/official_account"
    "github.com/jcbowen/wego/core"
)

func main() {
    // 创建公众号客户端
    config := &official_account.Config{
        AppID:     "your_app_id",
        AppSecret: "your_app_secret",
        Token:     "your_token",
        EncodingAESKey: "your_encoding_aes_key",
    }
    
    client := official_account.NewClient(config)
    oauthClient := official_account.NewOAuthClient(client)
    
    // HTTP路由设置
    http.HandleFunc("/oauth/authorize", func(w http.ResponseWriter, r *http.Request) {
        ctx := context.Background()
        
        // 生成授权URL
        req := &official_account.OAuthAuthorizeRequest{
            AppID:       config.AppID,
            RedirectURI: "https://yourdomain.com/oauth/callback",
            Scope:       core.OAuthScopeUserInfo,
            State:       "secure_state_123",
        }
        
        authURL, err := oauthClient.GenerateAuthorizeURL(ctx, req)
        if err != nil {
            http.Error(w, "生成授权URL失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 重定向到授权页面
        http.Redirect(w, r, authURL, http.StatusFound)
    })
    
    http.HandleFunc("/oauth/callback", func(w http.ResponseWriter, r *http.Request) {
        ctx := context.Background()
        
        // 获取授权码
        code := r.URL.Query().Get("code")
        state := r.URL.Query().Get("state")
        
        if code == "" {
            http.Error(w, "授权码不能为空", http.StatusBadRequest)
            return
        }
        
        // 验证state参数（防止CSRF攻击）
        if state != "secure_state_123" {
            http.Error(w, "State参数不匹配", http.StatusBadRequest)
            return
        }
        
        // 使用授权码获取AccessToken
        tokenResp, err := oauthClient.GetAccessToken(ctx, code)
        if err != nil {
            http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 获取用户信息
        userInfo, err := oauthClient.GetUserInfo(ctx, tokenResp.AccessToken, tokenResp.OpenID, "zh_CN")
        if err != nil {
            http.Error(w, "获取用户信息失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 显示用户信息
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprintf(w, `
            <h1>授权成功</h1>
            <p>昵称: %s</p>
            <p>头像: <img src="%s" width="100"></p>
            <p>性别: %s</p>
            <p>城市: %s</p>
            <p>国家: %s</p>
            <p>OpenID: %s</p>
            <p>UnionID: %s</p>
        `, userInfo.Nickname, userInfo.HeadImgURL, getGenderText(userInfo.Sex), 
           userInfo.City, userInfo.Country, tokenResp.OpenID, tokenResp.UnionID)
    })
    
    fmt.Println("OAuth服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}

func getGenderText(sex int) string {
    switch sex {
    case 1:
        return "男"
    case 2:
        return "女"
    default:
        return "未知"
    }
}
```

### 静默授权示例

```go
// 静默授权（只获取OpenID）
func handleSilentAuth(oauthClient *official_account.OAuthClient, w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
    
    req := &official_account.OAuthAuthorizeRequest{
        AppID:       "your_app_id",
        RedirectURI: "https://yourdomain.com/oauth/silent_callback",
        Scope:       core.OAuthScopeBase, // 静默授权
        State:       "silent_state",
    }
    
    authURL, err := oauthClient.GenerateAuthorizeURL(ctx, req)
    if err != nil {
        http.Error(w, "生成授权URL失败: "+err.Error(), http.StatusInternalServerError)
        return
    }
    
    // 重定向到授权页面
    http.Redirect(w, r, authURL, http.StatusFound)
}

func handleSilentCallback(oauthClient *official_account.OAuthClient, w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
    code := r.URL.Query().Get("code")
    
    if code == "" {
        http.Error(w, "授权码不能为空", http.StatusBadRequest)
        return
    }
    
    // 使用授权码获取AccessToken（只能获取OpenID）
    tokenResp, err := oauthClient.GetAccessToken(ctx, code)
    if err != nil {
        http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
        return
    }
    
    // 静默授权只能获取OpenID，不能获取用户详细信息
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprintf(w, `
        <h1>静默授权成功</h1>
        <p>OpenID: %s</p>
        <p>注意：静默授权只能获取OpenID，无法获取用户详细信息</p>
    `, tokenResp.OpenID)
}
```

## 安全注意事项

### 1. State参数防CSRF

```go
import (
    "crypto/rand"
    "encoding/base64"
)

// 生成安全的State参数
func generateSecureState() string {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        panic(err)
    }
    
    return base64.URLEncoding.EncodeToString(bytes)
}

// 验证State参数
func validateState(receivedState, expectedState string) bool {
    return receivedState == expectedState
}
```

### 2. Token安全存储

```go
// 安全的Token存储示例
func safeStoreOAuthToken(sessionID string, token *official_account.OAuthAccessTokenResponse) error {
    // 在实际应用中，应该加密存储Token
    // 这里简化处理，实际应该使用安全的存储方案
    
    // 存储到Session或安全的存储介质
    sessionStore[sessionID] = token
    return nil
}

// 安全的Token获取
func safeGetOAuthToken(sessionID string) (*official_account.OAuthAccessTokenResponse, error) {
    token, exists := sessionStore[sessionID]
    if !exists {
        return nil, fmt.Errorf("Token不存在")
    }
    
    return token, nil
}
```

## 最佳实践

### 1. 会话管理
- 使用安全的Session管理机制
- 设置合理的Session过期时间
- 实现Session清理机制

### 2. 错误处理
- 完善的错误页面
- 用户友好的错误提示
- 错误日志记录

### 3. 性能优化
- Token缓存减少API调用
- 连接池提高性能
- 异步处理耗时操作

### 4. 用户体验
- 清晰的授权说明
- 流畅的授权流程
- 授权失败的重试机制

## 注意事项

### 1. 授权范围选择
- snsapi_base：静默授权，只获取OpenID
- snsapi_userinfo：需要用户确认，获取完整用户信息
- 根据业务需求选择合适的授权范围

### 2. 频率限制
- 网页授权有调用频率限制
- 避免频繁的授权请求
- 实现合理的缓存策略

### 3. 安全性
- 使用HTTPS保护通信安全
- 验证所有输入参数
- 防止重放攻击

通过WeGo库的网页授权功能，您可以轻松实现公众号的OAuth2.0授权，为用户提供安全的第三方登录体验。