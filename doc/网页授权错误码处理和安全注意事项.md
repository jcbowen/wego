# 微信网页授权错误码处理和安全注意事项

## 概述

本文档详细介绍了微信网页授权功能中常见的错误码、安全注意事项和最佳实践。适用于微信公众号平台和微信开放平台两种授权场景。

## 错误码处理

### 基础错误码定义

在WeGo库中，核心错误码定义在<mcfile name="constants.go" path="/core/constants.go"></mcfile>文件中：

```go
// 基础错误码
ErrCodeSuccess           = 0
ErrCodeInvalidCredential = 40001
ErrCodeInvalidGrantType  = 40002
ErrCodeInvalidOpenID     = 40003
ErrCodeInvalidMediaType  = 40004
ErrCodeInvalidFileSize   = 40005
ErrCodeInvalidFileFormat = 40006
ErrCodeInvalidParams     = 40013
ErrCodeUnauthorized      = 48001
ErrCodeAccessDenied      = 48004
ErrCodeAPIQuotaExceeded  = 45009
```

### 网页授权特定错误码

#### 1. 授权URL生成阶段错误

| 错误码 | 错误描述 | 解决方案 |
|--------|----------|----------|
| 40001 | 无效凭证 | 检查AppID和AppSecret是否正确 |
| 40013 | 无效参数 | 检查redirect_uri、scope等参数格式 |
| 48001 | 未授权 | 检查公众号是否已认证 |

#### 2. 授权码换取AccessToken阶段错误

| 错误码 | 错误描述 | 解决方案 |
|--------|----------|----------|
| 40029 | 无效授权码 | 检查code参数是否正确，是否已过期 |
| 40163 | 授权码已使用 | 每个授权码只能使用一次 |
| 41008 | 缺少授权码 | 检查是否传递了code参数 |

#### 3. 用户信息获取阶段错误

| 错误码 | 错误描述 | 解决方案 |
|--------|----------|----------|
| 40003 | 无效OpenID | 检查OpenID是否正确 |
| 40014 | 无效AccessToken | 检查AccessToken是否有效 |
| 42001 | AccessToken过期 | 使用RefreshToken刷新 |

#### 4. Token刷新阶段错误

| 错误码 | 错误描述 | 解决方案 |
|--------|----------|----------|
| 40030 | 无效RefreshToken | 检查RefreshToken是否正确 |
| 40125 | RefreshToken已失效 | 需要重新授权获取新的RefreshToken |

### 错误处理最佳实践

#### 1. 统一错误处理机制

```go
// 错误处理示例
func handleOAuthError(err error, w http.ResponseWriter) {
    if err == nil {
        return
    }
    
    // 解析API错误响应
    if apiErr, ok := err.(*core.APIResponse); ok {
        switch apiErr.ErrCode {
        case core.ErrCodeInvalidCredential:
            http.Error(w, "应用凭证无效，请检查AppID和AppSecret", http.StatusBadRequest)
        case core.ErrCodeInvalidParams:
            http.Error(w, "请求参数错误，请检查参数格式", http.StatusBadRequest)
        case core.ErrCodeAPIQuotaExceeded:
            http.Error(w, "API调用频率超限，请稍后重试", http.StatusTooManyRequests)
        default:
            http.Error(w, fmt.Sprintf("微信API错误: %d - %s", apiErr.ErrCode, apiErr.ErrMsg), http.StatusInternalServerError)
        }
        return
    }
    
    // 处理其他错误
    http.Error(w, fmt.Sprintf("系统错误: %v", err), http.StatusInternalServerError)
}
```

#### 2. 重试机制

```go
// 带重试的API调用
func callAPIWithRetry(ctx context.Context, maxRetries int, fn func() error) error {
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // 检查是否需要重试
        if shouldRetry(err) {
            time.Sleep(time.Duration(i+1) * time.Second) // 指数退避
            continue
        }
        
        // 不需要重试的错误
        break
    }
    
    return lastErr
}

func shouldRetry(err error) bool {
    if apiErr, ok := err.(*core.APIResponse); ok {
        // 网络错误、频率限制等可以重试
        switch apiErr.ErrCode {
        case 45009, 45011, 45015: // 频率限制相关错误
            return true
        case -1: // 系统繁忙
            return true
        }
    }
    
    // 网络错误可以重试
    if strings.Contains(err.Error(), "timeout") || 
       strings.Contains(err.Error(), "network") {
        return true
    }
    
    return false
}
```

## 安全注意事项

### 1. 防止CSRF攻击

#### State参数验证

```go
// 生成安全的state参数
func generateSecureState() string {
    randomBytes := make([]byte, 16)
    if _, err := rand.Read(randomBytes); err != nil {
        // 使用时间戳作为fallback
        return fmt.Sprintf("%d", time.Now().UnixNano())
    }
    return hex.EncodeToString(randomBytes)
}

// 验证state参数
func validateState(originalState, receivedState string) bool {
    if originalState == "" || receivedState == "" {
        return false
    }
    
    // 简单的字符串比较
    return originalState == receivedState
}

// 在授权回调中验证state
func oauthCallbackHandler(w http.ResponseWriter, r *http.Request) {
    code := r.URL.Query().Get("code")
    state := r.URL.Query().Get("state")
    
    // 从session中获取原始state
    sessionState := getSessionState(r)
    
    if !validateState(sessionState, state) {
        http.Error(w, "State参数不匹配，可能存在CSRF攻击", http.StatusBadRequest)
        return
    }
    
    // 继续处理授权逻辑
    // ...
}
```

### 2. Token安全存储

#### 安全的Token存储方案

```go
// Token存储接口
type TokenStorage interface {
    SaveOAuthToken(ctx context.Context, sessionID string, token interface{}) error
    GetOAuthToken(ctx context.Context, sessionID string) (interface{}, error)
    DeleteOAuthToken(ctx context.Context, sessionID string) error
}

// 安全的Token存储实现
type SecureTokenStorage struct {
    encryptionKey []byte
    storage       TokenStorage
}

func (s *SecureTokenStorage) SaveOAuthToken(ctx context.Context, sessionID string, token interface{}) error {
    // 序列化Token
    tokenData, err := json.Marshal(token)
    if err != nil {
        return fmt.Errorf("序列化Token失败: %v", err)
    }
    
    // 加密Token数据
    encryptedData, err := s.encrypt(tokenData)
    if err != nil {
        return fmt.Errorf("加密Token失败: %v", err)
    }
    
    return s.storage.SaveOAuthToken(ctx, sessionID, encryptedData)
}

func (s *SecureTokenStorage) GetOAuthToken(ctx context.Context, sessionID string) (interface{}, error) {
    encryptedData, err := s.storage.GetOAuthToken(ctx, sessionID)
    if err != nil {
        return nil, err
    }
    
    // 解密Token数据
    decryptedData, err := s.decrypt(encryptedData.([]byte))
    if err != nil {
        return nil, fmt.Errorf("解密Token失败: %v", err)
    }
    
    var token interface{}
    if err := json.Unmarshal(decryptedData, &token); err != nil {
        return nil, fmt.Errorf("反序列化Token失败: %v", err)
    }
    
    return token, nil
}
```

### 3. 输入验证和参数检查

#### 参数验证函数

```go
// 验证授权请求参数
func validateOAuthRequest(req *OAuthAuthorizeRequest) error {
    if req.AppID == "" {
        return fmt.Errorf("AppID不能为空")
    }
    
    if req.RedirectURI == "" {
        return fmt.Errorf("RedirectURI不能为空")
    }
    
    // 验证URL格式
    if !isValidURL(req.RedirectURI) {
        return fmt.Errorf("RedirectURI格式无效")
    }
    
    // 验证授权范围
    if req.Scope != core.OAuthScopeBase && req.Scope != core.OAuthScopeUserInfo {
        return fmt.Errorf("无效的scope值: %s", req.Scope)
    }
    
    return nil
}

// 验证URL格式
func isValidURL(urlStr string) bool {
    u, err := url.Parse(urlStr)
    if err != nil {
        return false
    }
    
    // 必须使用HTTPS（生产环境）
    if u.Scheme != "https" && !strings.Contains(u.Host, "localhost") {
        return false
    }
    
    return u.Host != ""
}
```

### 4. 日志和监控

#### 安全日志记录

```go
// 安全日志记录器
type SecurityLogger struct {
    logger debugger.LoggerInterface
}

func (s *SecurityLogger) LogOAuthAttempt(ctx context.Context, appID, ip, userAgent string, success bool, err error) {
    logData := map[string]interface{}{
        "app_id":     appID,
        "ip":         ip,
        "user_agent": userAgent,
        "success":    success,
        "timestamp":  time.Now().Unix(),
    }
    
    if err != nil {
        logData["error"] = err.Error()
    }
    
    if success {
        s.logger.Info("OAuth授权成功", logData)
    } else {
        s.logger.Warn("OAuth授权失败", logData)
    }
}

func (s *SecurityLogger) LogTokenRefresh(ctx context.Context, appID, openID string, success bool) {
    logData := map[string]interface{}{
        "app_id":    appID,
        "openid":    openID,
        "success":   success,
        "timestamp": time.Now().Unix(),
    }
    
    if success {
        s.logger.Info("Token刷新成功", logData)
    } else {
        s.logger.Warn("Token刷新失败", logData)
    }
}
```

## 最佳实践

### 1. 授权流程安全最佳实践

#### 完整的授权流程安全检查

```go
// 安全的授权流程处理
func safeOAuthFlow(ctx context.Context, oauthClient *official_account.OAuthClient, code, state string) (*OAuthUserInfoResponse, error) {
    // 1. 验证输入参数
    if code == "" {
        return nil, fmt.Errorf("授权码不能为空")
    }
    
    if state == "" {
        return nil, fmt.Errorf("State参数不能为空")
    }
    
    // 2. 验证state参数（防止CSRF）
    if !validateStoredState(state) {
        return nil, fmt.Errorf("State参数验证失败")
    }
    
    // 3. 获取AccessToken
    tokenResp, err := oauthClient.GetAccessToken(ctx, code)
    if err != nil {
        return nil, fmt.Errorf("获取AccessToken失败: %v", err)
    }
    
    // 4. 验证Token有效性
    isValid, err := oauthClient.ValidateAccessToken(ctx, tokenResp.AccessToken, tokenResp.OpenID)
    if err != nil {
        return nil, fmt.Errorf("验证Token失败: %v", err)
    }
    
    if !isValid {
        return nil, fmt.Errorf("AccessToken无效")
    }
    
    // 5. 获取用户信息
    userInfo, err := oauthClient.GetUserInfo(ctx, tokenResp.AccessToken, tokenResp.OpenID, "zh_CN")
    if err != nil {
        // 即使获取用户信息失败，也返回基础信息
        return nil, fmt.Errorf("获取用户信息失败: %v", err)
    }
    
    return userInfo, nil
}
```

### 2. 错误页面和用户体验

#### 用户友好的错误页面

```go
// 错误页面模板
const errorPageTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>授权失败</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        .error { color: #d63031; }
        .retry-btn { background: #0984e3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
    </style>
</head>
<body>
    <h1 class="error">授权失败</h1>
    <p>{{.ErrorMessage}}</p>
    <p>错误代码: {{.ErrorCode}}</p>
    <button class="retry-btn" onclick="window.location.href='{{.RetryURL}}'">重新授权</button>
    <p><a href="/">返回首页</a></p>
</body>
</html>
`

// 渲染错误页面
func renderErrorPage(w http.ResponseWriter, errorMessage, errorCode, retryURL string) {
    data := map[string]interface{}{
        "ErrorMessage": errorMessage,
        "ErrorCode":    errorCode,
        "RetryURL":     retryURL,
    }
    
    tmpl := template.Must(template.New("error").Parse(errorPageTemplate))
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    
    if err := tmpl.Execute(w, data); err != nil {
        http.Error(w, "渲染错误页面失败", http.StatusInternalServerError)
    }
}
```

### 3. 性能和安全平衡

#### 缓存策略

```go
// 安全的Token缓存
type SafeTokenCache struct {
    cache      *cache.Cache
    maxEntries int
    ttl        time.Duration
}

func NewSafeTokenCache(maxEntries int, ttl time.Duration) *SafeTokenCache {
    return &SafeTokenCache{
        cache:      cache.New(cache.NoExpiration, 10*time.Minute),
        maxEntries: maxEntries,
        ttl:        ttl,
    }
}

func (c *SafeTokenCache) Set(key string, value interface{}) error {
    // 检查缓存大小
    if c.cache.ItemCount() >= c.maxEntries {
        // 清理过期的条目
        c.cleanup()
    }
    
    return c.cache.Set(key, value, c.ttl)
}

func (c *SafeTokenCache) Get(key string) (interface{}, bool) {
    return c.cache.Get(key)
}

func (c *SafeTokenCache) cleanup() {
    // 清理过期的缓存条目
    c.cache.DeleteExpired()
}
```

## 总结

通过实施上述错误码处理和安全注意事项，您可以：

1. **提高系统稳定性**：完善的错误处理机制确保系统在各种异常情况下都能正常运行
2. **增强安全性**：防止CSRF攻击、安全存储Token、验证输入参数等措施保护用户数据安全
3. **改善用户体验**：友好的错误页面和重试机制提升用户满意度
4. **便于维护**：清晰的错误码分类和日志记录便于问题排查和系统维护

建议在实际项目中根据具体需求调整和完善这些安全措施，确保微信网页授权功能的安全性和可靠性。