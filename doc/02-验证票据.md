# 02-验证票据(component_verify_ticket)

## 概述

component_verify_ticket是微信开放平台用于验证第三方平台服务器有效性的重要票据。微信服务器会每隔10分钟定时推送component_verify_ticket到第三方平台的消息接收URL。

## 票据推送机制

### 推送频率
- 每10分钟推送一次
- 票据有效期为30分钟
- 新票据会覆盖旧票据

### 推送格式
票据以XML格式推送，包含加密的消息内容：

```xml
<xml>
   <AppId><![CDATA[第三方平台AppID]]></AppId>
   <CreateTime>1413192605</CreateTime>
   <InfoType><![CDATA[component_verify_ticket]]></InfoType>
   <ComponentVerifyTicket><![CDATA[加密的票据内容]]></ComponentVerifyTicket>
</xml>
```

## WeGo库实现

### 票据接收处理

WeGo库提供了完整的票据接收和处理机制：

```go
// 处理票据推送消息
func (client *WegoClient) HandleVerifyTicket(msg *Message) (*MessageResponse, error) {
    if msg.InfoType != "component_verify_ticket" {
        return nil, fmt.Errorf("不是票据推送消息")
    }
    
    // 存储票据
    err := client.storage.SetVerifyTicket(msg.ComponentVerifyTicket)
    if err != nil {
        return nil, fmt.Errorf("存储票据失败: %v", err)
    }
    
    // 返回成功响应
    return &MessageResponse{
        ErrCode: 0,
        ErrMsg:  "ok",
    }, nil
}
```

### 票据获取和使用

```go
// 获取当前票据
func (client *WegoClient) GetVerifyTicket() (string, error) {
    ticket, err := client.storage.GetVerifyTicket()
    if err != nil {
        return "", fmt.Errorf("获取票据失败: %v", err)
    }
    
    if ticket == "" {
        return "", fmt.Errorf("票据不存在")
    }
    
    return ticket, nil
}

// 使用票据获取ComponentAccessToken
func (client *WegoClient) GetComponentAccessToken(ctx context.Context) (string, int, error) {
    ticket, err := client.GetVerifyTicket()
    if err != nil {
        return "", 0, fmt.Errorf("获取票据失败: %v", err)
    }
    
    // 调用API获取ComponentAccessToken
    return client.api.GetComponentAccessToken(ctx, ticket)
}
```

## 完整示例

### 1. 配置消息处理器

```go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "net/http"
    "github.com/jcbowen/wego"
)

func main() {
    config := &wego.WeGoConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWeGo(config)
    
    // 设置消息处理器
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        ctx := context.Background()
        
        // 验证消息签名
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        // 解析XML消息
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "读取请求体失败", http.StatusBadRequest)
            return
        }
        
        // 解密消息
        msg, err := client.DecryptMessage(string(body), signature, timestamp, nonce)
        if err != nil {
            http.Error(w, "消息解密失败", http.StatusBadRequest)
            return
        }
        
        // 处理不同类型的消息
        switch msg.InfoType {
        case "component_verify_ticket":
            // 处理票据推送
            response, err := client.HandleVerifyTicket(msg)
            if err != nil {
                log.Printf("处理票据失败: %v", err)
                http.Error(w, "处理票据失败", http.StatusInternalServerError)
                return
            }
            
            // 返回成功响应
            w.Header().Set("Content-Type", "application/xml")
            w.Write([]byte(response.ToXML()))
            
        case "unauthorized":
            // 处理取消授权事件
            // ...
            
        case "updateauthorized":
            // 处理授权更新事件
            // ...
            
        default:
            // 其他类型消息
            log.Printf("收到未知消息类型: %s\n", msg.InfoType)
        }
    })
    
    // 启动服务器
    log.Println("消息处理服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 2. 票据使用示例

```go
// 在需要调用API的地方使用票据
func someBusinessLogic(client *wego.WegoClient) error {
    ctx := context.Background()
    
    // 获取ComponentAccessToken（内部会自动使用票据）
    token, expiresIn, err := client.GetComponentAccessToken(ctx)
    if err != nil {
        return fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }
    
    fmt.Printf("ComponentAccessToken: %s, 有效期: %d秒\n", token, expiresIn)
    
    // 使用token调用其他API
    // ...
    
    return nil
}
```

## 存储实现

WeGo库支持多种存储方式：

### 文件存储（默认）
```go
// 使用文件存储（默认存储策略，适合生产环境）
client := wego.NewWeGo(config)
```

**默认存储策略**：
- 默认存储为文件存储
- 文件存储使用`wego_storage`目录保存Token数据
- 如果文件存储创建失败，会自动回退到内存存储并记录警告日志

### 内存存储
```go
// 使用内存存储（适合开发和测试）
storage := wego.NewMemoryStorage()
client := wego.NewWeGoWithStorage(config, storage)
```

### 自定义文件存储路径
```go
// 使用自定义路径的文件存储
storage := wego.NewFileStorage("/path/to/storage/file.json")
client := wego.NewWeGoWithStorage(config, storage)
```

### 数据库存储
```go
// 使用数据库存储（需要实现TokenStorage接口）
type DatabaseStorage struct {
    db *sql.DB
}

func (s *DatabaseStorage) SetVerifyTicket(ticket string) error {
    // 实现数据库存储逻辑
}

func (s *DatabaseStorage) GetVerifyTicket() (string, error) {
    // 实现数据库查询逻辑
}

// 使用自定义存储
storage := &DatabaseStorage{db: yourDB}
client := wego.NewWxOpenClientWithStorage(config, storage)
```

## 注意事项

### 1. 票据有效期
- 票据有效期为30分钟
- 每10分钟推送新票据
- 需要及时存储新票据

### 2. 服务稳定性
- 确保票据接收服务稳定运行
- 实现票据的持久化存储
- 处理网络异常和重试机制

### 3. 安全性
- 验证消息签名防止伪造
- 使用HTTPS保护数据传输
- 妥善保管EncodingAESKey

## 常见问题

### Q: 收不到票据推送
A: 检查服务器配置是否正确，网络是否可达，消息签名验证是否通过

### Q: 票据获取失败
A: 检查存储实现是否正确，票据是否已过期或被覆盖

### Q: ComponentAccessToken获取失败
A: 检查票据是否存在且有效，网络连接是否正常

## 相关API

- `HandleVerifyTicket()` - 处理票据推送消息
- `GetVerifyTicket()` - 获取当前票据
- `GetComponentAccessToken()` - 使用票据获取ComponentAccessToken
- `DecryptMessage()` - 解密推送消息

通过wxopen组件，您可以轻松处理component_verify_ticket的接收、存储和使用，确保第三方平台服务的稳定运行。