# 09-代公众号网页授权

## 概述

代公众号网页授权是第三方平台代公众号实现OAuth2.0网页授权的功能。wxopen组件提供了完整的网页授权实现，支持授权码模式和静默授权模式。

## 授权流程

### 1. 授权码模式（snsapi_userinfo）
1. 引导用户到授权页面
2. 用户同意授权
3. 微信回调到第三方平台
4. 使用授权码获取AccessToken
5. 获取用户信息

### 2. 静默授权模式（snsapi_base）
1. 引导用户到授权页面
2. 用户无感知授权
3. 微信回调到第三方平台
4. 使用授权码获取AccessToken
5. 只能获取OpenID

## wxopen组件实现

### 网页授权客户端

```go
// OAuthClient 网页授权客户端
type OAuthClient struct {
    authorizerClient *AuthorizerClient
    redirectURI      string
}

// 创建OAuth客户端
func (ac *AuthorizerClient) GetOAuthClient(redirectURI string) *OAuthClient {
    return &OAuthClient{
        authorizerClient: ac,
        redirectURI:      redirectURI,
    }
}
```

### 授权URL生成

```go
// 生成授权页面URL
func (oc *OAuthClient) GetAuthorizeURL(scope, state string) string {
    params := url.Values{}
    params.Set("appid", oc.authorizerClient.appID)
    params.Set("redirect_uri", oc.redirectURI)
    params.Set("response_type", "code")
    params.Set("scope", scope)
    params.Set("state", state)
    params.Set("component_appid", oc.authorizerClient.client.config.ComponentAppID)
    
    return "https://open.weixin.qq.com/connect/oauth2/authorize?" + params.Encode() + "#wechat_redirect"
}

// 生成静默授权URL
func (oc *OAuthClient) GetBaseAuthorizeURL(state string) string {
    return oc.GetAuthorizeURL("snsapi_base", state)
}

// 生成用户信息授权URL
func (oc *OAuthClient) GetUserInfoAuthorizeURL(state string) string {
    return oc.GetAuthorizeURL("snsapi_userinfo", state)
}
```

### 授权码处理

```go
// 使用授权码获取AccessToken
func (oc *OAuthClient) GetAccessToken(code string) (*OAuthToken, error) {
    apiURL := "https://api.weixin.qq.com/sns/oauth2/component/access_token"
    
    params := map[string]interface{}{
        "appid":                  oc.authorizerClient.appID,
        "code":                   code,
        "grant_type":             "authorization_code",
        "component_appid":        oc.authorizerClient.client.config.ComponentAppID,
        "component_access_token": "", // 需要先获取ComponentAccessToken
    }
    
    // 获取ComponentAccessToken
    componentToken, _, err := oc.authorizerClient.client.GetComponentAccessToken()
    if err != nil {
        return nil, fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }
    params["component_access_token"] = componentToken
    
    respBody, err := oc.authorizerClient.CallAPI(apiURL, params)
    if err != nil {
        return nil, err
    }
    
    var oauthToken OAuthToken
    if err := json.Unmarshal(respBody, &oauthToken); err != nil {
        return nil, err
    }
    
    return &oauthToken, nil
}
```

### 用户信息获取

```go
// 获取用户信息
func (oc *OAuthClient) GetUserInfo(accessToken, openID string) (*OAuthUserInfo, error) {
    apiURL := "https://api.weixin.qq.com/sns/userinfo"
    
    params := map[string]interface{}{
        "access_token": accessToken,
        "openid":       openID,
        "lang":         "zh_CN",
    }
    
    respBody, err := oc.authorizerClient.CallAPI(apiURL, params)
    if err != nil {
        return nil, err
    }
    
    var userInfo OAuthUserInfo
    if err := json.Unmarshal(respBody, &userInfo); err != nil {
        return nil, err
    }
    
    return &userInfo, nil
}

// 刷新AccessToken
func (oc *OAuthClient) RefreshToken(refreshToken string) (*OAuthToken, error) {
    apiURL := "https://api.weixin.qq.com/sns/oauth2/component/refresh_token"
    
    params := map[string]interface{}{
        "appid":                  oc.authorizerClient.appID,
        "grant_type":             "refresh_token",
        "refresh_token":          refreshToken,
        "component_appid":        oc.authorizerClient.client.config.ComponentAppID,
        "component_access_token": "",
    }
    
    // 获取ComponentAccessToken
    componentToken, _, err := oc.authorizerClient.client.GetComponentAccessToken()
    if err != nil {
        return nil, fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }
    params["component_access_token"] = componentToken
    
    respBody, err := oc.authorizerClient.CallAPI(apiURL, params)
    if err != nil {
        return nil, err
    }
    
    var oauthToken OAuthToken
    if err := json.Unmarshal(respBody, &oauthToken); err != nil {
        return nil, err
    }
    
    return &oauthToken, nil
}
```

## 完整示例

### 1. 网页授权示例

```go
package main

import (
    "fmt"
    "net/http"
    "github.com/jcbowen/wego"
)

func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // 授权方信息
    authorizerAppID := "授权方AppID"
    redirectURI := "https://yourdomain.com/oauth/callback"
    
    // 获取授权方客户端
    authorizerClient := client.GetAuthorizerClient(authorizerAppID)
    
    // 获取OAuth客户端
    oauthClient := authorizerClient.GetOAuthClient(redirectURI)
    
    // HTTP路由设置
    http.HandleFunc("/oauth/authorize", func(w http.ResponseWriter, r *http.Request) {
        // 生成授权URL
        authURL := oauthClient.GetUserInfoAuthorizeURL("your_state")
        
        // 重定向到授权页面
        http.Redirect(w, r, authURL, http.StatusFound)
    })
    
    http.HandleFunc("/oauth/callback", func(w http.ResponseWriter, r *http.Request) {
        // 获取授权码
        code := r.URL.Query().Get("code")
        state := r.URL.Query().Get("state")
        
        if code == "" {
            http.Error(w, "授权码不能为空", http.StatusBadRequest)
            return
        }
        
        // 验证state参数（防止CSRF攻击）
        if state != "your_state" {
            http.Error(w, "State参数不匹配", http.StatusBadRequest)
            return
        }
        
        // 使用授权码获取AccessToken
        oauthToken, err := oauthClient.GetAccessToken(code)
        if err != nil {
            http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 获取用户信息
        userInfo, err := oauthClient.GetUserInfo(oauthToken.AccessToken, oauthToken.OpenID)
        if err != nil {
            http.Error(w, "获取用户信息失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 显示用户信息
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprintf(w, `
            <h1>授权成功</h1>
            <p>昵称: %s</p>
            <p>头像: <img src="%s" width="100"></p>
            <p>性别: %s</p>
            <p>城市: %s</p>
            <p>国家: %s</p>
        `, userInfo.Nickname, userInfo.HeadImgURL, userInfo.Sex, userInfo.City, userInfo.Country)
    })
    
    fmt.Println("OAuth服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 2. 静默授权示例

```go
// 静默授权（只获取OpenID）
func handleSilentAuth(oauthClient *wego.OAuthClient, w http.ResponseWriter, r *http.Request) {
    // 生成静默授权URL
    authURL := oauthClient.GetBaseAuthorizeURL("silent_state")
    
    // 重定向到授权页面
    http.Redirect(w, r, authURL, http.StatusFound)
}

func handleSilentCallback(oauthClient *wego.OAuthClient, w http.ResponseWriter, r *http.Request) {
    code := r.URL.Query().Get("code")
    
    if code == "" {
        http.Error(w, "授权码不能为空", http.StatusBadRequest)
        return
    }
    
    // 使用授权码获取AccessToken（只能获取OpenID）
    oauthToken, err := oauthClient.GetAccessToken(code)
    if err != nil {
        http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
        return
    }
    
    // 静默授权只能获取OpenID，不能获取用户详细信息
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprintf(w, `
        <h1>静默授权成功</h1>
        <p>OpenID: %s</p>
        <p>注意：静默授权只能获取OpenID，无法获取用户详细信息</p>
    `, oauthToken.OpenID)
}
```

## 安全考虑

### 1. State参数防CSRF

```go
// 生成安全的State参数
func generateSecureState() string {
    // 使用加密随机数生成State
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        panic(err)
    }
    
    return base64.URLEncoding.EncodeToString(bytes)
}

// 验证State参数
func validateState(receivedState, expectedState string) bool {
    // 简单的字符串比较（实际应用中可能需要更复杂的验证）
    return receivedState == expectedState
}
```

### 2. Token安全存储

```go
// 安全的Token存储
func safeStoreOAuthToken(sessionID string, token *wego.OAuthToken) error {
    // 加密存储Token
    encryptedToken, err := encryptToken(token)
    if err != nil {
        return err
    }
    
    // 存储到安全的存储介质（如Redis、数据库）
    err = storage.Set(sessionID, encryptedToken, token.ExpiresIn)
    if err != nil {
        return err
    }
    
    return nil
}

// 安全的Token获取
func safeGetOAuthToken(sessionID string) (*wego.OAuthToken, error) {
    encryptedToken, err := storage.Get(sessionID)
    if err != nil {
        return nil, err
    }
    
    token, err := decryptToken(encryptedToken)
    if err != nil {
        return nil, err
    }
    
    return token, nil
}
```

## 最佳实践

### 1. 会话管理
- 使用安全的Session管理
- 设置合理的Session过期时间
- 实现Session清理机制

### 2. 错误处理
- 完善的错误页面
- 用户友好的错误提示
- 错误日志记录

### 3. 性能优化
- Token缓存减少API调用
- 连接池提高性能
- 异步处理耗时操作

### 4. 用户体验
- 清晰的授权说明
- 流畅的授权流程
- 授权失败的重试机制

## 注意事项

### 1. 授权范围
- snsapi_base：静默授权，只获取OpenID
- snsapi_userinfo：需要用户确认，获取完整用户信息
- 根据业务需求选择合适的授权范围

### 2. 频率限制
- 网页授权有调用频率限制
- 避免频繁的授权请求
- 实现合理的缓存策略

### 3. 安全性
- 使用HTTPS保护通信安全
- 验证所有输入参数
- 防止重放攻击

## 常见问题

### Q: 授权页面显示"redirect_uri参数错误"
A: 检查授权回调域名配置、redirect_uri参数格式

### Q: 获取AccessToken失败
A: 检查授权码是否有效、ComponentAccessToken是否正确

### Q: 获取用户信息失败
A: 检查授权范围是否为snsapi_userinfo、AccessToken是否有效

通过wxopen组件的网页授权功能，您可以轻松实现公众号的OAuth2.0授权，为用户提供安全的第三方登录体验。