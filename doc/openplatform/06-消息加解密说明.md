# 06-消息加解密说明

## 概述

微信开放平台要求第三方平台对接收和发送的消息进行加密解密，确保通信安全。wxopen组件实现了完整的消息加解密功能，符合微信安全规范。

## 加解密原理（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>

### 1. 加密流程
1. 生成16位随机字符串（random）
2. 构造明文：random(16B) + msg_len(4B) + msg + appid
3. 使用AES-256-CBC模式加密（使用aesKey前16字节作为IV）
4. Base64编码加密结果
5. 生成消息签名：msg_signature = sha1(sort(token、timestamp、nonce、msg_encrypt))

### 2. 解密流程
1. 验证消息签名（使用msg_signature参数）
2. Base64解码加密消息
3. 使用AES-256-CBC模式解密
4. 解析消息结构：random(16B) + msg_len(4B) + msg + appid
5. 验证AppID的正确性
6. 如果当前EncodingAESKey解密失败，尝试使用上一次的EncodingAESKey<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>

## wxopen组件实现

### 加解密核心方法

```go
// 加密消息（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>
func (c *WXBizMsgCrypt) EncryptMsg(replyMsg, timestamp, nonce string) (string, string, error) {
    aesKey, err := DecodeAESKey(c.EncodingAESKey)
    if err != nil {
        return "", "", fmt.Errorf("EncodingAESKey解码失败: %v", err)
    }
    
    encrypted, err := EncryptMsg(replyMsg, c.AppID, aesKey)
    if err != nil {
        return "", "", fmt.Errorf("加密失败: %v", err)
    }
    
    // 生成签名（符合微信官方规范：token、timestamp、nonce、msg_encrypt）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>
    signature := genSignature(c.Token, timestamp, nonce, encrypted)
    return encrypted, signature, nil
}

// 解密消息（符合微信官方规范，支持使用上一次的EncodingAESKey）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>
func (c *WXBizMsgCrypt) DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg string) (string, error) {
    // 首先验证消息签名（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>
    if !c.VerifySignature(msgSignature, timestamp, nonce, encryptedMsg) {
        return "", fmt.Errorf("消息签名验证失败")
    }

    // 首先使用当前的EncodingAESKey尝试解密
    aesKey, err := DecodeAESKey(c.EncodingAESKey)
    if err != nil {
        return "", fmt.Errorf("当前EncodingAESKey解码失败: %v", err)
    }
    
    result, err := DecryptMsg(encryptedMsg, aesKey)
    if err == nil {
        return result, nil
    }
    
    // 如果当前密钥解密失败，尝试使用上一次的EncodingAESKey（官方要求）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>
    if c.PrevEncodingAESKey != "" {
        prevAesKey, err := DecodeAESKey(c.PrevEncodingAESKey)
        if err != nil {
            return "", fmt.Errorf("上一次EncodingAESKey解码失败: %v", err)
        }
        
        result, err = DecryptMsg(encryptedMsg, prevAesKey)
        if err == nil {
            // 使用上一次密钥解密成功，说明EncodingAESKey已经更新
            // 需要将当前密钥保存为上一次密钥，并更新当前密钥为新的密钥
            if c.storage != nil {
                // 保存当前密钥为上一次密钥
                ctx := context.Background()
                err := c.storage.SavePrevEncodingAESKey(ctx, c.AppID, c.EncodingAESKey)
                if err != nil {
                    // 保存失败不影响解密结果，但记录错误
                    fmt.Printf("警告：保存上一次EncodingAESKey失败: %v\n", err)
                }
            }

            // 更新实例中的密钥状态
            // 将当前密钥保存为上一次密钥
            prevKey := c.EncodingAESKey
            // 更新当前密钥为新的EncodingAESKey（即上一次成功解密的密钥）
            c.EncodingAESKey = c.PrevEncodingAESKey
            // 更新上一次密钥为原来的当前密钥
            c.PrevEncodingAESKey = prevKey

            return result, nil
        }
    }
    
    return "", fmt.Errorf("解密失败，当前和上一次EncodingAESKey均无法解密: %v", err)
}
```

### 签名验证

```go
// 生成签名（符合微信官方规范：token、timestamp、nonce、msg_encrypt）
func genSignature(token, timestamp, nonce, msgEncrypt string) string {
    params := []string{token, timestamp, nonce, msgEncrypt}
    sort.Strings(params)
    
    combined := strings.Join(params, "")
    hash := sha1.Sum([]byte(combined))
    
    return hex.EncodeToString(hash[:])
}

// 验证签名
func (c *WXBizMsgCrypt) VerifySignature(msgSignature, timestamp, nonce, encryptedMsg string) bool {
    expectedSignature := genSignature(c.Token, timestamp, nonce, encryptedMsg)
    return expectedSignature == msgSignature
}
```

## 完整示例

### 1. 加解密使用示例

```go
package main

import (
    "fmt"
    "github.com/jcbowen/wego"
)

func main() {
    // 初始化加解密器
    crypto := wego.NewWXBizMsgCrypt(
        "your_token",
        "your_encoding_aes_key", 
        "your_app_id",
    )
    
    // 示例：解密消息
    msgSignature := "接收到的消息签名"
    timestamp := "时间戳"
    nonce := "随机数"
    encryptedMsg := "加密的消息内容"
    
    decryptedMsg, err := crypto.DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg)
    if err != nil {
        fmt.Printf("解密失败: %v\n", err)
        return
    }
    
    fmt.Printf("解密后的消息: %s\n", decryptedMsg)
    
    // 示例：加密回复消息
    replyMsg := `<xml><ToUserName><![CDATA[toUser]]></ToUserName><FromUserName><![CDATA[fromUser]]></FromUserName><CreateTime>12345678</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[你好]]></Content></xml>`
    
    encryptedReply, signature, err := crypto.EncryptMsg(replyMsg, timestamp, nonce)
    if err != nil {
        fmt.Printf("加密失败: %v\n", err)
        return
    }
    
    fmt.Printf("加密后的回复: %s\n", encryptedReply)
    fmt.Printf("签名: %s\n", signature)
}
```

### 2. HTTP服务器集成

```go
func handleWxCallback(w http.ResponseWriter, r *http.Request) {
    crypto := wego.NewWXBizMsgCrypt("your_token", "your_encoding_aes_key", "your_app_id")
    
    // 获取URL参数
    signature := r.URL.Query().Get("msg_signature")
    timestamp := r.URL.Query().Get("timestamp") 
    nonce := r.URL.Query().Get("nonce")
    
    // 处理URL验证（首次配置）
    if echostr := r.URL.Query().Get("echostr"); echostr != "" {
        decryptedEchostr, err := crypto.VerifyURL(signature, timestamp, nonce, echostr)
        if err != nil {
            http.Error(w, "URL验证失败", http.StatusBadRequest)
            return
        }
        w.Write([]byte(decryptedEchostr))
        return
    }
    
    // 读取请求体
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "读取请求体失败", http.StatusBadRequest)
        return
    }
    
    // 解析XML获取加密消息
    var encryptedMsg string
    // 解析逻辑...
    
    // 解密消息
    decryptedMsg, err := crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    if err != nil {
        http.Error(w, "消息解密失败", http.StatusBadRequest)
        return
    }
    
    // 处理业务逻辑
    response := processBusinessLogic(decryptedMsg)
    
    // 加密回复
    encryptedResponse, err := crypto.EncryptMsg(response, timestamp, nonce)
    if err != nil {
        http.Error(w, "回复加密失败", http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/xml")
    w.Write([]byte(encryptedResponse))
}
```

## 加解密最佳实践

### 1. 密钥管理
- 安全存储EncodingAESKey
- 定期更换密钥
- 实现密钥备份机制

### 2. 错误处理
- 完善的错误日志记录
- 优雅的错误恢复
- 监控加解密成功率

### 3. 性能优化
- 缓存加解密实例
- 使用连接池
- 避免重复初始化

### 4. 安全考虑
- 验证所有输入参数
- 防止重放攻击
- 实现速率限制

## 注意事项

### 1. 编码要求
- EncodingAESKey必须是43位
- 使用Base64编码
- 注意字符编码问题

### 2. 时间戳验证
- 验证时间戳有效性
- 防止重放攻击
- 设置合理的时间窗口

### 3. 随机数管理
- 使用安全的随机数生成器
- 确保随机数唯一性
- 实现随机数验证

## 常见问题

### Q: 签名验证失败
A: 检查Token、时间戳、随机数、加密消息的顺序和内容

### Q: 解密失败
A: 检查EncodingAESKey是否正确、消息格式是否标准

### Q: AppID不匹配
A: 检查加解密时使用的AppID与配置是否一致

## 相关API

- `EncryptMsg()` - 加密消息
- `DecryptMsg()` - 解密消息
- `VerifyURL()` - 验证URL
- `ValidateSignature()` - 验证签名

通过wxopen组件的加解密功能，您可以确保与微信服务器的通信安全可靠。