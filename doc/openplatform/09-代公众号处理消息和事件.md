# 09-代公众号处理消息和事件

## 概述

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Official_Accounts/Handling_of_news_and_events.html" index="9">9</mcreference>，第三方平台在代公众号处理消息和事件时，必须遵循以下规范：

1. 消息和事件推送会发送到公众号消息与事件接收URL
2. 开发者必须在5秒内进行处理
3. 必须对消息收发过程进行加解密处理
4. 支持安全模式下的消息加解密

WeGo库提供了符合官方标准的消息和事件处理机制。

## 消息类型

### 1. 文本消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1348831860</CreateTime>
  <MsgType><![CDATA[text]]></MsgType>
  <Content><![CDATA[this is a text message]]></Content>
  <MsgId>1234567890123456</MsgId>
</xml>
```

### 2. 图片消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1348831860</CreateTime>
  <MsgType><![CDATA[image]]></MsgType>
  <PicUrl><![CDATA[this is a url]]></PicUrl>
  <MediaId><![CDATA[media_id]]></MediaId>
  <MsgId>1234567890123456</MsgId>
</xml>
```

### 3. 语音消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1357290913</CreateTime>
  <MsgType><![CDATA[voice]]></MsgType>
  <MediaId><![CDATA[media_id]]></MediaId>
  <Format><![CDATA[Format]]></Format>
  <Recognition><![CDATA[腾讯微信团队]]></Recognition>
  <MsgId>1234567890123456</MsgId>
</xml>
```

### 4. 视频消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1357290913</CreateTime>
  <MsgType><![CDATA[video]]></MsgType>
  <MediaId><![CDATA[media_id]]></MediaId>
  <ThumbMediaId><![CDATA[thumb_media_id]]></ThumbMediaId>
  <MsgId>1234567890123456</MsgId>
</xml>
```

### 5. 位置消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1351776360</CreateTime>
  <MsgType><![CDATA[location]]></MsgType>
  <Location_X>23.134521</Location_X>
  <Location_Y>113.358803</Location_Y>
  <Scale>20</Scale>
  <Label><![CDATA[位置信息]]></Label>
  <MsgId>1234567890123456</MsgId>
</xml>
```

### 6. 链接消息
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1351776360</CreateTime>
  <MsgType><![CDATA[link]]></MsgType>
  <Title><![CDATA[公众平台官网链接]]></Title>
  <Description><![CDATA[公众平台官网链接]]></Description>
  <Url><![CDATA[url]]></Url>
  <MsgId>1234567890123456</MsgId>
</xml>
```

## 事件类型

### 1. 关注/取消关注事件
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>123456789</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[subscribe]]></Event>
</xml>
```

### 2. 菜单点击事件
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>123456789</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[CLICK]]></Event>
  <EventKey><![CDATA[EVENTKEY]]></EventKey>
</xml>
```

### 3. 扫描二维码事件
```xml
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>123456789</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[SCAN]]></Event>
  <EventKey><![CDATA[SCENE_VALUE]]></EventKey>
  <Ticket><![CDATA[TICKET]]></Ticket>
</xml>
```

## WeGo库实现

### 消息处理器接口

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="5">5</mcreference>和<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="6">6</mcreference>，消息处理必须支持加解密。WeGo库提供了以下接口：

```go
// MessageHandler 消息处理器接口
type MessageHandler interface {
    HandleMessage(msg *Message) (interface{}, error)
}

// EventHandler 事件处理器接口
type EventHandler interface {
    HandleEvent(event *EventMessage) (interface{}, error)
}

// ComponentVerifyTicketHandler 第三方平台component_verify_ticket事件处理器接口
type ComponentVerifyTicketHandler interface {
    HandleComponentVerifyTicket(event *ComponentVerifyTicketEvent) error
}

// AuthorizeEventHandler 第三方平台授权事件处理器接口
type AuthorizeEventHandler interface {
    HandleAuthorizeEvent(event interface{}) error
}
```

### 默认消息处理器

```go
// DefaultMessageHandler 默认消息处理器
type DefaultMessageHandler struct{}

func (h *DefaultMessageHandler) HandleMessage(msg *Message) (interface{}, error) {
    // 根据消息类型进行默认处理
    switch msg.MsgType {
    case "text":
        // 处理文本消息
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: fmt.Sprintf("收到文本消息: %s", msg.Content),
        }, nil
    case "image":
        // 处理图片消息
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: "收到图片消息",
        }, nil
    case "event":
        // 处理事件消息
        return h.handleEvent(msg)
    default:
        // 其他消息类型
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: "收到消息",
        }, nil
    }
}

func (h *DefaultMessageHandler) handleEvent(msg *Message) (interface{}, error) {
    // 这里需要根据具体的事件类型进行处理
    // 实际实现中需要解析Event字段
    return &TextMessage{
        Message: Message{
            ToUserName:   msg.FromUserName,
            FromUserName: msg.ToUserName,
            CreateTime:   time.Now().Unix(),
            MsgType:      "text",
        },
        Content: "收到事件消息",
    }, nil
}
```

### 消息处理流程

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="5">5</mcreference>，消息处理流程必须包含签名验证、消息解密、XML解析和类型分发。WeGo库提供了以下处理流程：

```go
// MessageProcessor 消息处理器
type MessageProcessor struct {
    messageHandlers               map[string]MessageHandler
    eventHandlers                 map[string]EventHandler
    componentVerifyTicketHandlers []ComponentVerifyTicketHandler
    authorizeEventHandlers        []AuthorizeEventHandler
}

// ProcessMessage 处理消息
func (p *MessageProcessor) ProcessMessage(xmlData []byte) (interface{}, error) {
    // 解析基础消息类型
    var baseMsg Message
    if err := xml.Unmarshal(xmlData, &baseMsg); err != nil {
        return nil, fmt.Errorf("解析XML消息失败: %v", err)
    }

    // 检查是否为第三方平台特殊事件
    if baseMsg.MsgType == MessageTypeEvent {
        var eventMsg EventMessage
        if err := xml.Unmarshal(xmlData, &eventMsg); err == nil {
            // 检查是否为第三方平台特定事件
            switch eventMsg.Event {
            case EventTypeComponentVerifyTicket, EventTypeAuthorized, EventTypeUpdateAuthorized, EventTypeUnauthorized:
                return p.handleThirdPartyMessage(xmlData, &baseMsg)
            }
        }
    }

    // 根据消息类型进行具体解析
    switch baseMsg.MsgType {
    case MessageTypeEvent:
        return p.processEventMessage(xmlData)
    case MessageTypeText:
        return p.processTextMessage(xmlData)
    case MessageTypeImage:
        return p.processImageMessage(xmlData)
    case MessageTypeVoice:
        return p.processVoiceMessage(xmlData)
    case MessageTypeVideo:
        return p.processVideoMessage(xmlData)
    case MessageTypeLocation:
        return p.processLocationMessage(xmlData)
    case MessageTypeLink:
        return p.processLinkMessage(xmlData)
    default:
        return nil, fmt.Errorf("不支持的消息类型: %s", baseMsg.MsgType)
    }
}

// 完整的HTTP消息处理示例
func handleWeChatMessage(w http.ResponseWriter, r *http.Request) {
    // 1. 获取URL参数
    msgSignature := r.URL.Query().Get("msg_signature")
    timestamp := r.URL.Query().Get("timestamp")
    nonce := r.URL.Query().Get("nonce")
    authorizerAppID := r.URL.Query().Get("authorizer_appid") // 从URL参数获取授权方AppID
    
    // 2. 读取请求体
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "读取请求体失败", http.StatusBadRequest)
        return
    }
    
    // 3. 使用SecureMessageProcessor处理安全消息
    processor := message.NewSecureMessageProcessor()
    result, err := processor.ProcessSecureMessage(msgSignature, timestamp, nonce, authorizerAppID, string(body))
    if err != nil {
        http.Error(w, fmt.Sprintf("消息处理失败: %v", err), http.StatusBadRequest)
        return
    }
    
    // 4. 根据处理结果返回响应
    if result == nil {
        // 不需要回复的情况，返回success
        w.Write([]byte("success"))
    } else {
        // 需要回复的情况，ProcessSecureMessage已经返回加密后的回复
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(result.(string)))
    }
}
```

## 完整示例

### 1. 自定义消息处理器

```go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "net/http"
    "github.com/jcbowen/wego"
)

// CustomMessageHandler 自定义消息处理器
type CustomMessageHandler struct {
    authorizerAppID string
}

func (h *CustomMessageHandler) HandleTextMessage(msg *wego.TextMessage) (*wego.ReplyMessage, error) {
    // 自定义文本消息处理逻辑
    content := fmt.Sprintf("您发送了: %s (来自自定义处理器)", msg.Content)
    
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      content,
    }
    
    return reply, nil
}

func (h *CustomMessageHandler) HandleImageMessage(msg *wego.ImageMessage) (*wego.ReplyMessage, error) {
    // 自定义图片消息处理逻辑
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      fmt.Sprintf("收到图片，MediaID: %s", msg.MediaId),
    }
    
    return reply, nil
}

func (h *CustomMessageHandler) HandleSubscribeEvent(msg *wego.SubscribeEvent) (*wego.ReplyMessage, error) {
    // 自定义关注事件处理逻辑
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      "欢迎关注我们的公众号！这里有精彩内容等着您！",
    }
    
    return reply, nil
}

// 实现其他消息处理方法...

func main() {
    config := &wego.WeGoConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWeGo(config)
    
    // 创建消息处理器
    messageProcessor := wego.NewMessageProcessor(client)
    
    // 注册自定义消息处理器
    authorizerAppID := "授权方AppID"
    customHandler := &CustomMessageHandler{
        authorizerAppID: authorizerAppID,
    }
    messageProcessor.RegisterHandler(authorizerAppID, customHandler)
    
    // HTTP消息处理接口
    http.HandleFunc("/message", func(w http.ResponseWriter, r *http.Request) {
        ctx := context.Background()
        
        // 验证消息签名
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        // 获取授权方AppID（可以从URL参数或请求头中获取）
        authorizerAppID := r.URL.Query().Get("authorizer_appid")
        
        // 读取请求体
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "读取请求体失败", http.StatusBadRequest)
            return
        }
        
        // 处理消息
        reply, err := messageProcessor.ProcessMessage(ctx, authorizerAppID, string(body))
        if err != nil {
            log.Printf("处理消息失败: %v", err)
            http.Error(w, "处理消息失败", http.StatusInternalServerError)
            return
        }
        
        // 返回回复消息
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(reply))
    })
    
    log.Println("消息处理服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 2. 多公众号消息处理

```go
// MultiAuthorizerMessageHandler 多公众号消息处理器
type MultiAuthorizerMessageHandler struct {
    handlers map[string]wego.MessageHandler
}

func NewMultiAuthorizerMessageHandler() *MultiAuthorizerMessageHandler {
    return &MultiAuthorizerMessageHandler{
        handlers: make(map[string]wego.MessageHandler),
    }
}

func (h *MultiAuthorizerMessageHandler) RegisterHandler(authorizerAppID string, handler wego.MessageHandler) {
    h.handlers[authorizerAppID] = handler
}

func (h *MultiAuthorizerMessageHandler) HandleTextMessage(msg *wego.TextMessage) (*wego.ReplyMessage, error) {
    // 根据消息中的ToUserName判断是哪个公众号
    // 这里需要维护一个ToUserName到authorizerAppID的映射
    authorizerAppID := getAuthorizerAppIDByToUserName(msg.ToUserName)
    
    if handler, exists := h.handlers[authorizerAppID]; exists {
        return handler.HandleTextMessage(msg)
    }
    
    // 返回默认处理
    return &wego.DefaultMessageHandler{}.HandleTextMessage(msg)
}

// 实现其他消息处理方法...

// 维护ToUserName到authorizerAppID的映射
func getAuthorizerAppIDByToUserName(toUserName string) string {
    // 这里可以从数据库或配置文件中获取映射关系
    mapping := map[string]string{
        "公众号1原始ID": "公众号1AppID",
        "公众号2原始ID": "公众号2AppID",
        // ...
    }
    
    return mapping[toUserName]
}
```

## 消息处理最佳实践

### 1. 异步处理

```go
// AsyncMessageProcessor 异步消息处理器
type AsyncMessageProcessor struct {
    syncProcessor *wego.MessageProcessor
    messageQueue chan *AsyncMessage
}

type AsyncMessage struct {
    AuthorizerAppID string
    EncryptedMsg    string
    ResponseChan    chan *AsyncResponse
}

type AsyncResponse struct {
    Reply string
    Error error
}

func NewAsyncMessageProcessor(client *wego.WegoClient) *AsyncMessageProcessor {
    processor := &AsyncMessageProcessor{
        syncProcessor: wego.NewMessageProcessor(client),
        messageQueue: make(chan *AsyncMessage, 1000), // 缓冲队列
    }
    
    // 启动工作协程
    go processor.startWorkers(10) // 10个工作协程
    
    return processor
}

func (p *AsyncMessageProcessor) ProcessMessageAsync(authorizerAppID, encryptedMsg string) <-chan *AsyncResponse {
    responseChan := make(chan *AsyncResponse, 1)
    
    asyncMsg := &AsyncMessage{
        AuthorizerAppID: authorizerAppID,
        EncryptedMsg:    encryptedMsg,
        ResponseChan:    responseChan,
    }
    
    // 将消息放入队列
    p.messageQueue <- asyncMsg
    
    return responseChan
}

func (p *AsyncMessageProcessor) startWorkers(numWorkers int) {
    for i := 0; i < numWorkers; i++ {
        go p.worker()
    }
}

func (p *AsyncMessageProcessor) worker() {
    for asyncMsg := range p.messageQueue {
        ctx := context.Background()
        reply, err := p.syncProcessor.ProcessMessage(ctx, asyncMsg.AuthorizerAppID, asyncMsg.EncryptedMsg)
        
        response := &AsyncResponse{
            Reply: reply,
            Error: err,
        }
        
        asyncMsg.ResponseChan <- response
        close(asyncMsg.ResponseChan)
    }
}
```

### 2. 消息持久化

```go
// MessageLogger 消息日志记录器
type MessageLogger struct {
    db *sql.DB
}

func (l *MessageLogger) LogMessage(authorizerAppID string, msg interface{}, direction string) error {
    // 将消息转换为JSON
    msgJSON, err := json.Marshal(msg)
    if err != nil {
        return err
    }
    
    // 插入数据库
    _, err = l.db.Exec(`
        INSERT INTO message_logs 
        (authorizer_appid, message, direction, created_at) 
        VALUES (?, ?, ?, ?)
    `, authorizerAppID, string(msgJSON), direction, time.Now())
    
    return err
}
```

### 3. 消息去重

```go
// MessageDeduplicator 消息去重器
type MessageDeduplicator struct {
    cache *redis.Client
}

func (d *MessageDeduplicator) IsDuplicate(msgID string) bool {
    // 检查消息ID是否已存在
    exists, err := d.cache.Exists("msg:" + msgID).Result()
    if err != nil {
        return false // 出错时不过滤
    }
    
    if exists > 0 {
        return true // 消息已存在
    }
    
    // 设置消息ID缓存，过期时间5分钟
    d.cache.Set("msg:"+msgID, "1", 5*time.Minute)
    
    return false
}
```

## 注意事项

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Handling_of_news_and_events.html" index="9">9</mcreference>，消息与事件处理需要特别注意以下事项：

### 1. 消息安全要求
- **签名验证**：必须验证消息签名，确保消息来源可信
- **加密传输**：使用HTTPS协议传输消息，防止中间人攻击
- **重放攻击防护**：通过时间戳和随机数验证防止消息重放
- **消息加解密**：支持安全模式下的消息加密和解密

### 2. 性能与可靠性
- **5秒响应**：必须在5秒内完成消息处理并返回响应
- **异步处理**：对于耗时操作应采用异步处理机制
- **超时设置**：合理设置HTTP请求超时时间
- **错误重试**：实现适当的错误重试机制

### 3. 错误处理规范
- **错误日志**：记录详细的错误信息用于问题排查
- **优雅降级**：在部分功能不可用时提供优雅的降级方案
- **用户提示**：提供用户友好的错误提示信息
- **监控告警**：建立消息处理性能监控和告警机制

### 4. 第三方平台特殊要求
- **component_verify_ticket处理**：正确处理组件验证票据推送<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="2">2</mcreference>
- **授权事件处理**：处理授权成功、取消授权等事件<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="3">3</mcreference>
- **消息推送URL**：配置正确的消息推送URL并验证其有效性

### 5. 兼容性考虑
- **消息格式兼容**：确保与微信官方消息格式完全兼容
- **版本兼容**：考虑不同微信版本的兼容性问题
- **编码兼容**：正确处理UTF-8编码的消息内容

通过WeGo库的消息与事件处理功能，您可以轻松实现第三方平台的消息自动回复、事件处理等核心功能，为用户提供更好的互动体验。