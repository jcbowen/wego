# 05-消息推送介绍

## 概述

消息推送是微信开放平台向第三方平台推送各种事件和消息的机制。wego组件提供了完整的消息接收、解析和处理功能，支持多种消息类型的处理。

## 消息类型

### 1. 事件推送
- 授权变更事件（authorized/unauthorized/updateauthorized）
- 票据推送事件（component_verify_ticket）
- 其他业务事件

### 2. 用户消息推送
- 文本消息
- 图片消息
- 语音消息
- 视频消息
- 地理位置消息
- 链接消息

### 3. 菜单事件
- 点击菜单事件
- 扫码推事件
- 扫码推事件且弹出"消息接收中"提示框
- 弹出系统拍照发图事件
- 弹出拍照或者相册发图事件
- 弹出微信相册发图事件
- 弹出地理位置选择器事件

## 消息推送流程

### 1. 消息接收
微信服务器向第三方平台配置的URL推送加密消息，URL参数包含：
- `msg_signature` - 消息签名（必须使用此参数验证，不要使用signature参数）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- `timestamp` - 时间戳
- `nonce` - 随机数
- `openid` - 发送方账号（OpenID）
- `encrypt_type` - 加密类型（固定为"aes"）
- `signature` - 微信加密签名（仅用于URL验证，消息验证请使用msg_signature）

### 2. 消息验证
验证`msg_signature`签名，确保消息来源可信。签名验证方法：
- 将`token`、`timestamp`、`nonce`、`Encrypt`（包体内的加密字段）四个参数进行字典序排序<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- 将四个参数字符串拼接成一个字符串进行sha1计算
- 与URL参数中的`msg_signature`进行对比
- **重要**：必须使用`msg_signature`参数进行验证，不要使用`signature`参数

### 3. 消息解密
使用EncodingAESKey解密消息内容，解密流程：
- `AESKey = Base64_Decode(消息加解密Key + "=")`
- 将`Encrypt`密文进行Base64解码
- 使用AESKey进行AES解密（CBC模式，PKCS#7填充）
- 解密结果格式：`random(16B) + msg_len(4B) + msg + appid`

### 4. 消息处理
根据消息类型调用相应的处理器。

### 5. 响应返回
在5秒内返回处理结果，如需加密回复则按照相同流程加密。

## wego组件实现

### 消息处理器接口

```go
// MessageHandler 消息处理器接口（符合微信官方消息格式）
type MessageHandler interface {
    // 处理消息
    HandleMessage(msg *Message) (interface{}, error)
}

// EventHandler 事件处理器接口
type EventHandler interface {
    // 处理事件
    HandleEvent(event *EventMessage) (interface{}, error)
}

// ComponentVerifyTicketHandler 第三方平台component_verify_ticket事件处理器接口
type ComponentVerifyTicketHandler interface {
    // 处理component_verify_ticket事件
    HandleComponentVerifyTicket(event *ComponentVerifyTicketEvent) error
}

// AuthorizeEventHandler 第三方平台授权事件处理器接口
type AuthorizeEventHandler interface {
    // 处理授权事件
    HandleAuthorizeEvent(event interface{}) error
}

// 默认消息处理器
type DefaultMessageHandler struct{}

func (h *DefaultMessageHandler) HandleMessage(msg *Message) (interface{}, error) {
    // 根据消息类型进行默认处理
    switch msg.MsgType {
    case "text":
        // 处理文本消息
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: fmt.Sprintf("收到文本消息: %s", msg.Content),
        }, nil
    case "image":
        // 处理图片消息
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: "收到图片消息",
        }, nil
    case "event":
        // 处理事件消息
        return h.handleEvent(msg)
    default:
        // 其他消息类型
        return &TextMessage{
            Message: Message{
                ToUserName:   msg.FromUserName,
                FromUserName: msg.ToUserName,
                CreateTime:   time.Now().Unix(),
                MsgType:      "text",
            },
            Content: "收到消息",
        }, nil
    }
}

func (h *DefaultMessageHandler) handleEvent(msg *Message) (interface{}, error) {
    // 这里需要根据具体的事件类型进行处理
    // 实际实现中需要解析Event字段
    return &TextMessage{
        Message: Message{
            ToUserName:   msg.FromUserName,
            FromUserName: msg.ToUserName,
            CreateTime:   time.Now().Unix(),
            MsgType:      "text",
        },
        Content: "收到事件消息",
    }, nil
}
```

### 消息处理流程

```go
// MessageProcessor 消息处理器
type MessageProcessor struct {
    messageHandlers               map[string]MessageHandler
    eventHandlers                 map[string]EventHandler
    componentVerifyTicketHandlers []ComponentVerifyTicketHandler
    authorizeEventHandlers        []AuthorizeEventHandler
}

// ProcessMessage 处理消息（符合微信官方消息格式）
func (p *MessageProcessor) ProcessMessage(xmlData []byte) (interface{}, error) {
    // 解析基础消息类型
    var baseMsg Message
    if err := xml.Unmarshal(xmlData, &baseMsg); err != nil {
        return nil, fmt.Errorf("解析XML消息失败: %v", err)
    }

    // 检查是否为第三方平台特殊事件
    if baseMsg.MsgType == MessageTypeEvent {
        var eventMsg EventMessage
        if err := xml.Unmarshal(xmlData, &eventMsg); err == nil {
            // 检查是否为第三方平台特定事件
            switch eventMsg.Event {
            case EventTypeComponentVerifyTicket, EventTypeAuthorized, EventTypeUpdateAuthorized, EventTypeUnauthorized:
                return p.handleThirdPartyMessage(xmlData, &baseMsg)
            }
        }
    }

    // 根据消息类型进行具体解析
    switch baseMsg.MsgType {
    case MessageTypeEvent:
        return p.processEventMessage(xmlData)
    case MessageTypeText:
        return p.processTextMessage(xmlData)
    case MessageTypeImage:
        return p.processImageMessage(xmlData)
    case MessageTypeVoice:
        return p.processVoiceMessage(xmlData)
    case MessageTypeVideo:
        return p.processVideoMessage(xmlData)
    case MessageTypeLocation:
        return p.processLocationMessage(xmlData)
    case MessageTypeLink:
        return p.processLinkMessage(xmlData)
    default:
        return nil, fmt.Errorf("不支持的消息类型: %s", baseMsg.MsgType)
    }
}

// 处理事件消息（符合微信官方事件格式）
func (client *WxOpenClient) HandleEventMessage(msg *Message) (*MessageResponse, error) {
    switch msg.Event {
    case "subscribe", "unsubscribe":
        // 处理关注/取消关注事件
        return client.messageHandler.HandleSubscribeEvent(&SubscribeEvent{
            Message:    msg,
            Event:      msg.Event,
            EventKey:   msg.EventKey,
            CreateTime: msg.CreateTime,
        })
        
    case "SCAN":
        // 处理扫描带参数二维码事件
        return client.messageHandler.HandleScanEvent(&ScanEvent{
            Message:    msg,
            EventKey:   msg.EventKey,
            Ticket:     msg.Ticket,
            CreateTime: msg.CreateTime,
        })
        
    case "LOCATION":
        // 处理上报地理位置事件
        return client.messageHandler.HandleLocationEvent(&LocationEvent{
            Message:    msg,
            Latitude:   msg.Latitude,
            Longitude:  msg.Longitude,
            Precision:  msg.Precision,
            CreateTime: msg.CreateTime,
        })
        
    case "CLICK":
        // 处理菜单点击事件
        return client.messageHandler.HandleMenuClickEvent(&MenuClickEvent{
            Message:    msg,
            EventKey:   msg.EventKey,
            CreateTime: msg.CreateTime,
        })
        
    case "VIEW":
        // 处理菜单跳转链接事件
        return client.messageHandler.HandleMenuViewEvent(&MenuViewEvent{
            Message:    msg,
            EventKey:   msg.EventKey,
            CreateTime: msg.CreateTime,
        })
        
    case "TEMPLATESENDJOBFINISH":
        // 处理模板消息发送结果事件
        return client.messageHandler.HandleTemplateSendJobFinishEvent(&TemplateSendJobFinishEvent{
            Message:     msg,
            Status:      msg.Status,
            MsgID:       msg.MsgID,
            CreateTime:  msg.CreateTime,
        })
        
    default:
        // 对于未知事件类型，返回success避免微信服务器重试
        return &MessageResponse{
            ErrCode: 0,
            ErrMsg:  "success",
        }, nil
    }
}
```

## 完整示例

### 1. 自定义消息处理器

```go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "net/http"
    "github.com/jcbowen/wego"
)

// CustomMessageHandler 自定义消息处理器
type CustomMessageHandler struct {
    authorizerAppID string
}

func (h *CustomMessageHandler) HandleTextMessage(msg *wego.TextMessage) (*wego.ReplyMessage, error) {
    // 自定义文本消息处理逻辑
    content := fmt.Sprintf("您发送了: %s (来自自定义处理器)", msg.Content)
    
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      content,
    }
    
    return reply, nil
}

func (h *CustomMessageHandler) HandleImageMessage(msg *wego.ImageMessage) (*wego.ReplyMessage, error) {
    // 自定义图片消息处理逻辑
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      fmt.Sprintf("收到图片，MediaID: %s", msg.MediaId),
    }
    
    return reply, nil
}

func (h *CustomMessageHandler) HandleSubscribeEvent(msg *wego.SubscribeEvent) (*wego.ReplyMessage, error) {
    // 自定义关注事件处理逻辑
    reply := &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      "欢迎关注！感谢您的支持！",
    }
    
    return reply, nil
}

func (h *CustomMessageHandler) HandleMenuClickEvent(msg *wego.MenuClickEvent) (*wego.ReplyMessage, error) {
    // 自定义菜单点击事件处理逻辑
    var reply string
    switch msg.EventKey {
    case "V1001_TODAY_MUSIC":
        reply = "今日推荐音乐：周杰伦 - 晴天"
    case "V1001_GOOD":
        reply = "感谢您的点赞！"
    default:
        reply = "点击了菜单：" + msg.EventKey
    }
    
    return &wego.ReplyMessage{
        ToUserName:   msg.FromUserName,
        FromUserName: msg.ToUserName,
        CreateTime:   msg.CreateTime,
        MsgType:      "text",
        Content:      reply,
    }, nil
}
```

### 2. HTTP服务器集成

```go
// 完整的HTTP消息处理示例
func handleWeChatMessage(w http.ResponseWriter, r *http.Request) {
    // 1. 获取URL参数
    msgSignature := r.URL.Query().Get("msg_signature")
    timestamp := r.URL.Query().Get("timestamp")
    nonce := r.URL.Query().Get("nonce")
    authorizerAppID := r.URL.Query().Get("authorizer_appid") // 从URL参数获取授权方AppID
    
    // 2. 读取请求体
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "读取请求体失败", http.StatusBadRequest)
        return
    }
    
    // 3. 使用SecureMessageProcessor处理安全消息
    processor := message.NewSecureMessageProcessor()
    result, err := processor.ProcessSecureMessage(authorizerAppID, msgSignature, timestamp, nonce, string(body))
    if err != nil {
        http.Error(w, fmt.Sprintf("消息处理失败: %v", err), http.StatusBadRequest)
        return
    }
    
    // 4. 根据处理结果返回响应
    if result == nil {
        // 不需要回复的情况，返回success
        w.Write([]byte("success"))
    } else {
        // 需要回复的情况，ProcessSecureMessage已经返回加密后的回复
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(result.(string)))
    }
}

func main() {
    // 注册消息处理路由
    http.HandleFunc("/wego/callback", handleWeChatMessage)
    
    // 启动HTTP服务器
    log.Println("启动微信开放平台消息服务器，监听端口 8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatalf("服务器启动失败: %v", err)
    }
}
        
        // 加密响应
        encryptedResponse, err := client.EncryptMessage(response.ToXML())
        if err != nil {
            http.Error(w, "响应加密失败", http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(encryptedResponse))
    })
    
    fmt.Println("消息推送服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

## 消息处理最佳实践（完全符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>

### 1. 安全性最佳实践

#### 1.1 消息签名验证（官方强制要求）
- **必须使用msg_signature参数**：微信官方明确要求使用msg_signature进行签名验证，而非signature参数<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **5分钟时间窗口**：严格验证时间戳timestamp与当前时间差不超过5分钟，防止重放攻击
- **随机数防重放**：检查nonce是否在短时间内重复使用，确保消息唯一性
- **签名算法规范**：使用SHA1算法，参数按字典序排序：token、timestamp、nonce、encrypted_msg

#### 1.2 消息加解密安全（符合官方加密规范）
- **AES密钥管理**：EncodingAESKey必须是43位Base64编码的32字节密钥，符合微信官方要求
- **IV使用规范**：使用AES密钥的前16字节作为IV，符合CBC模式要求
- **PKCS#7填充**：严格按照PKCS#7标准进行填充和去填充，确保数据完整性
- **AppID验证**：解密后必须验证AppID的正确性，防止消息伪造

#### 1.3 通信安全（官方技术要求）
- **HTTPS强制要求**：所有消息推送接口必须使用HTTPS协议，确保数据传输安全
- **Token定期更换**：建议每3-6个月更换一次Token，增强安全性
- **EncodingAESKey轮换**：密钥轮换时需确保新旧密钥同时有效一段时间，避免服务中断

### 2. 性能优化最佳实践（符合官方响应要求）

#### 2.1 响应时间控制（官方5秒要求）
- **5秒响应要求**：微信服务器明确要求在5秒内完成消息处理并返回响应，超时将导致消息重试<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **异步处理机制**：对于耗时操作，先返回success，再异步处理业务逻辑，确保及时响应
- **超时控制**：设置合理的超时时间，避免阻塞微信服务器，影响消息推送稳定性

#### 2.2 资源管理（官方推荐实践）
- **连接池管理**：合理配置数据库和Redis连接池，提高消息处理效率
- **内存优化**：及时释放加解密过程中的临时变量，避免内存泄漏
- **缓存策略**：缓存Token验证结果、加解密实例等，减少重复计算

### 3. 错误处理最佳实践（官方错误处理规范）

#### 3.1 错误响应规范（官方要求）
- **加密模式错误**：必须返回明文"success"或加密的XML响应，避免返回错误信息<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **签名验证失败**：返回HTTP 400错误，并记录详细日志用于问题排查
- **解密失败处理**：返回适当的错误码，避免敏感信息泄露，确保系统安全

#### 3.2 日志记录（官方推荐实践）
- **完整请求日志**：记录timestamp、nonce、msg_signature等关键参数，便于问题追踪
- **错误分类记录**：区分签名错误、解密错误、业务逻辑错误，提高排查效率
- **监控告警**：设置关键错误的实时告警机制，确保问题及时发现和处理

### 4. 兼容性最佳实践（官方格式要求）

#### 4.1 消息格式兼容（官方XML规范）
- **XML格式要求**：严格按照微信官方XML格式要求，确保消息正确解析<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **字段完整性**：确保ToUserName、FromUserName、CreateTime等必填字段完整，避免格式错误
- **编码规范**：使用UTF-8编码，避免中文乱码问题，确保多语言支持

#### 4.2 版本兼容（官方推荐实践）
- **向后兼容**：确保新版本不影响已有功能，保持接口稳定性
- **灰度发布**：重要变更采用灰度发布策略，降低风险影响
- **测试验证**：充分测试各种消息类型和事件类型，确保兼容性

### 5. 运维监控最佳实践（官方服务要求）

#### 5.1 健康检查（官方服务稳定性要求）
- **定期自检**：实现消息处理服务的健康检查接口，确保服务可用性<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **性能监控**：监控消息处理耗时、成功率等关键指标，满足5秒响应要求
- **容量规划**：根据业务量合理规划服务器资源，确保消息推送稳定性

#### 5.2 灾难恢复（官方服务连续性要求）
- **多机房部署**：重要业务实现多机房容灾，提高服务可用性
- **数据备份**：定期备份关键配置和数据，防止数据丢失
- **应急预案**：制定详细的消息推送故障应急预案，确保快速恢复

## 注意事项（官方重要提醒）

### 1. 安全性（官方强制要求）
- **始终验证消息签名**：必须使用msg_signature参数进行签名验证，确保消息来源可信<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>
- **使用HTTPS保护数据传输**：所有消息推送接口必须使用HTTPS协议，确保数据安全
- **定期更换EncodingAESKey**：建议定期更换加密密钥，增强安全性

### 2. 可靠性（官方服务要求）
- **实现消息持久化存储**：确保消息不丢失，支持重试机制
- **处理网络异常和重试**：实现网络异常处理，支持微信服务器重试机制
- **监控服务可用性**：持续监控服务状态，确保消息推送可靠性

### 3. 兼容性（官方格式要求）
- **支持多种消息格式**：严格按照微信官方XML格式要求，确保兼容性
- **处理未知消息类型**：实现未知消息类型的默认处理逻辑
- **保持向后兼容**：确保新版本不影响已有功能，保持接口稳定性

## 常见问题（官方问题解答）

### Q: 消息解密失败
A: 检查EncodingAESKey是否正确（必须是43位Base64编码）、消息格式是否符合微信官方XML规范、签名验证是否使用msg_signature参数<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>

### Q: 响应超时（超过5秒）
A: 优化处理逻辑、实现异步处理、检查网络延迟，确保在5秒内完成消息处理并返回响应，避免微信服务器重试

### Q: 重复消息处理
A: 实现MsgID检查、设置消息去重机制，处理微信服务器的重试机制，确保消息幂等性

## 相关API（实际代码接口）

- `ProcessSecureMessage()` - 处理安全消息（包含签名验证、解密、处理和加密回复）
- `VerifyURL()` - 验证URL（使用msg_signature参数进行签名验证）
- `RegisterMessageHandler()` - 注册消息处理器
- `RegisterEventHandler()` - 注册事件处理器
- `NewSecureMessageProcessor()` - 创建安全消息处理器实例

通过wego组件，您可以轻松处理各种微信消息推送，构建功能丰富的第三方平台应用，完全符合微信官方规范<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/message_push.html" index="0">0</mcreference>