# 02-验证票据(component_verify_ticket)

## 概述

component_verify_ticket是微信开放平台用于验证第三方平台服务器有效性的重要票据。根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="0">0</mcreference>，微信服务器会每隔10分钟定时推送component_verify_ticket到第三方平台的"授权事件接收URL"。接收POST请求后，只需直接返回字符串"success"。

## 票据推送机制

### 推送频率
- 每10分钟推送一次
- 票据有效期为12小时，比component_access_token更长
- 新票据会覆盖旧票据
- 建议保存最近可用的component_verify_ticket，在component_access_token过期之前都可以直接使用该component_verify_ticket进行更新，避免出现因为component_verify_ticket接收失败而无法更新component_access_token的情况

### 推送格式
票据以XML格式推送，包含加密的消息内容：

```xml
<xml>
   <AppId><![CDATA[第三方平台AppID]]></AppId>
   <CreateTime>1413192605</CreateTime>
   <InfoType><![CDATA[component_verify_ticket]]></InfoType>
   <ComponentVerifyTicket><![CDATA[票据内容]]></ComponentVerifyTicket>
</xml>
```

**注意：** 实际推送的消息是经过加密的，需要使用微信提供的加解密算法进行解密后才能得到上述XML内容。

## WeGo库实现

### 票据接收处理

WeGo库提供了完整的票据接收和处理机制。根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="0">0</mcreference>，接收component_verify_ticket推送后，只需直接返回字符串"success"。

票据处理会自动在`HandleAuthorizationEvent`方法中完成：

```go
// 处理授权变更事件（包含component_verify_ticket）
// 支持明文和加密两种消息格式
// 根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>，
// 接收POST请求后只需直接返回字符串"success"
func (c *APIClient) HandleAuthorizationEvent(ctx context.Context, msgSignature, timestamp, nonce, encryptType string, body []byte) (string, error) {
    // 首先检测是否为加密消息
    var encryptedMsg struct {
        XMLName    xml.Name `xml:"xml"`
        AppId      string   `xml:"AppId"`
        Encrypt    string   `xml:"Encrypt"`
        CreateTime int64    `xml:"CreateTime"`
    }

    // 判断消息类型：根据encrypt_type参数或XML内容检测
    isEncrypted := encryptType == "aes" && msgSignature != ""

    // 如果URL参数表明是加密消息，或者XML内容包含Encrypt字段，则进行解密
    if isEncrypted {
        // 尝试解析XML获取加密内容
        if err := xml.Unmarshal(xmlData, &encryptedMsg); err != nil {
            return "success", nil // 即使解析失败也返回success
        }

        if encryptedMsg.Encrypt == "" {
            return "success", nil
        }

        // 解密消息
        decryptedData, err := c.DecryptMessage(encryptedMsg.Encrypt, msgSignature, timestamp, nonce)
        if err != nil {
            return "success", nil // 即使解密失败也返回success
        }

        // 使用解密后的数据继续处理
        xmlData = decryptedData
    }

    // 解析XML获取基础事件信息
    var baseEvent AuthorizationEvent
    err := xml.Unmarshal(xmlData, &baseEvent)
    if err != nil {
        return "success", nil // 即使解析失败也返回success
    }

    // 验证事件签名和时间戳
    if err := c.validateAuthorizationEvent(&baseEvent); err != nil {
        return "success", nil // 即使验证失败也返回success
    }

    // 根据事件类型进行处理
    switch baseEvent.InfoType {
    case "component_verify_ticket":
        var event ComponentVerifyTicketEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        // 存储验证票据
        if err := c.storage.SaveVerifyTicket(ctx, event.ComponentVerifyTicket); err != nil {
            // 记录错误日志，但依然返回success
        }

        if err := c.GetEventHandler().HandleComponentVerifyTicket(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }
    }

    // 根据微信官方文档要求，必须返回"success"字符串
    return "success", nil
}
```

### 票据获取和使用

```go
import (
    "context"
    "fmt"
    "time"
    
    "github.com/jcbowen/wego"
    "github.com/jcbowen/wego/openplatform"
    "github.com/jcbowen/wego/storage"
)

// 获取当前票据
func (client *openplatform.APIClient) GetVerifyTicket(ctx context.Context) (*storage.VerifyTicket, error) {
    ticket, err := client.storage.GetVerifyTicket(ctx)
    if err != nil {
        return nil, fmt.Errorf("获取票据失败: %v", err)
    }
    
    if ticket == nil {
        return nil, fmt.Errorf("票据不存在或已过期")
    }
    
    return ticket, nil
}

// 使用票据获取ComponentAccessToken
func (client *openplatform.APIClient) GetComponentAccessToken(ctx context.Context) (*storage.ComponentAccessToken, error) {
    // 内部会自动从存储中获取验证票据
    return client.GetComponentAccessToken(ctx, "")
}
```

## 完整示例

### 1. 配置消息处理器

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="0">0</mcreference>，接收component_verify_ticket推送后，只需直接返回字符串"success"。

```go
package main

import (
    "context"
    "fmt"
    "io"
    "log"
    "net/http"
    "time"
    "github.com/jcbowen/wego/openplatform"
    "github.com/jcbowen/wego/storage"
)

func main() {
    // 创建存储实例
    storage := storage.NewMemoryStorage()
    
    // 创建开放平台客户端
    client := openplatform.NewAPIClient(
        openplatform.WithStorage(storage),
        openplatform.WithComponentAppID("your_component_appid"),
        openplatform.WithComponentAppSecret("your_component_appsecret"),
    )
    
    // 设置消息处理器
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != "POST" {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        
        // 获取URL参数
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        encryptType := r.URL.Query().Get("encrypt_type")
        
        // 读取请求体
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "Bad request", http.StatusBadRequest)
            return
        }
        
        // 处理授权事件（包含component_verify_ticket）
        response, err := client.HandleAuthorizationEvent(context.Background(), body, signature, timestamp, nonce, encryptType)
        if err != nil {
            log.Printf("处理授权事件失败: %v", err)
            http.Error(w, "Internal server error", http.StatusInternalServerError)
            return
        }
        
        // 返回success
        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(response))
    })
    
    // 启动服务器
    log.Println("服务器启动在 :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 2. 票据使用示例

```go
// 在需要调用API的地方使用票据
func someBusinessLogic(client *wego.OpenPlatformClient) error {
    ctx := context.Background()
    
    // 获取ComponentAccessToken（内部会自动使用票据）
    token, expiresIn, err := client.GetComponentAccessToken(ctx)
    if err != nil {
        return fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }
    
    fmt.Printf("ComponentAccessToken: %s, 有效期: %d秒\n", token, expiresIn)
    
    // 使用token调用其他API
    // ...
    
    return nil
}
```

## 存储实现

WeGo库支持多种存储方式：

### 内存存储

```go
// 内存存储实现
func (s *MemoryStorage) SaveVerifyTicket(ctx context.Context, ticket string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.verifyTicket = &VerifyTicket{
        Ticket:    ticket,
        CreatedAt: time.Now(),
        ExpiresAt: time.Now().Add(12 * time.Hour), // 12小时有效期
    }
    
    return nil
}

func (s *MemoryStorage) GetVerifyTicket(ctx context.Context) (*VerifyTicket, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if s.verifyTicket == nil {
        return nil, nil
    }
    
    if time.Now().After(s.verifyTicket.ExpiresAt) {
        s.verifyTicket = nil // 清理过期票据
        return nil, nil
    }
    
    return s.verifyTicket, nil
}
```

### 文件存储

```go
// 文件存储实现
func (s *FileStorage) SaveVerifyTicket(ctx context.Context, ticket string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    verifyTicket := &VerifyTicket{
        Ticket:    ticket,
        CreatedAt: time.Now(),
        ExpiresAt: time.Now().Add(12 * time.Hour), // 12小时有效期
    }
    
    data, err := json.Marshal(verifyTicket)
    if err != nil {
        return fmt.Errorf("序列化票据失败: %v", err)
    }
    
    return os.WriteFile(s.verifyTicketPath, data, 0644)
}

func (s *FileStorage) GetVerifyTicket(ctx context.Context) (*VerifyTicket, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    data, err := os.ReadFile(s.verifyTicketPath)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, nil
        }
        return nil, fmt.Errorf("读取票据文件失败: %v", err)
    }
    
    var verifyTicket VerifyTicket
    if err := json.Unmarshal(data, &verifyTicket); err != nil {
        return nil, fmt.Errorf("解析票据数据失败: %v", err)
    }
    
    if time.Now().After(verifyTicket.ExpiresAt) {
        // 清理过期票据
        os.Remove(s.verifyTicketPath)
        return nil, nil
    }
    
    return &verifyTicket, nil
}
```

### 使用示例

```go
// 使用内存存储（适合开发和测试）
storage := wego.NewMemoryStorage()
client := wego.NewOpenPlatformClientWithStorage(config, storage)

// 使用文件存储（默认存储策略，适合生产环境）
storage := wego.NewFileStorage("/path/to/storage/file.json")
client := wego.NewOpenPlatformClientWithStorage(config, storage)

// 使用数据库存储（需要实现TokenStorage接口）
type DatabaseStorage struct {
    db *sql.DB
}

func (s *DatabaseStorage) SaveVerifyTicket(ctx context.Context, ticket string) error {
    // 实现数据库存储逻辑，记录创建时间和过期时间
    _, err := s.db.ExecContext(ctx, `
        INSERT INTO verify_tickets (ticket, created_at, expires_at) 
        VALUES (?, ?, ?) 
        ON DUPLICATE KEY UPDATE ticket = ?, created_at = ?, expires_at = ?
    `, ticket, time.Now(), time.Now().Add(12*time.Hour),
       ticket, time.Now(), time.Now().Add(12*time.Hour))
    return err
}

func (s *DatabaseStorage) GetVerifyTicket(ctx context.Context) (*wego.VerifyTicket, error) {
    var ticket string
    var createdAt, expiresAt time.Time
    
    err := s.db.QueryRowContext(ctx, `
        SELECT ticket, created_at, expires_at FROM verify_tickets 
        WHERE expires_at > ? 
        ORDER BY created_at DESC LIMIT 1
    `, time.Now()).Scan(&ticket, &createdAt, &expiresAt)
    
    if err == sql.ErrNoRows {
        return nil, nil
    }
    
    if err != nil {
        return nil, err
    }
    
    return &wego.VerifyTicket{
        Ticket:    ticket,
        CreatedAt: createdAt,
        ExpiresAt: expiresAt,
    }, nil
}

// 使用自定义存储
storage := &DatabaseStorage{db: yourDB}
client := wego.NewOpenPlatformClientWithStorage(config, storage)
```

## 注意事项

### 1. 票据有效期
- 票据有效期为12小时
- 每10分钟推送新票据
- 需要及时存储新票据

### 2. 服务稳定性
- 确保票据接收服务稳定运行
- 实现票据的持久化存储
- 处理网络异常和重试机制

### 3. 安全性
- 验证消息签名防止伪造
- 使用HTTPS保护数据传输
- 妥善保管EncodingAESKey

## 常见问题

### Q: 收不到票据推送
A: 检查服务器配置是否正确，网络是否可达，消息签名验证是否通过

### Q: 票据获取失败
A: 检查存储实现是否正确，票据是否已过期或被覆盖

### Q: ComponentAccessToken获取失败
A: 检查票据是否存在且有效，网络连接是否正常

## 相关API

- `HandleVerifyTicket()` - 处理票据推送消息
- `GetVerifyTicket()` - 获取当前票据
- `GetComponentAccessToken()` - 使用票据获取ComponentAccessToken
- `DecryptMessage()` - 解密推送消息
- `HandleAuthorizationEvent(ctx context.Context, msgSignature, timestamp, nonce, encryptType string, body []byte) (string, error)` - 处理授权变更事件，支持明文和加密消息格式，包含component_verify_ticket事件处理

通过wxopen组件，您可以轻松处理component_verify_ticket的接收、存储和使用，确保第三方平台服务的稳定运行。