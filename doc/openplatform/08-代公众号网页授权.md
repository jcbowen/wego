# 08-代公众号网页授权

## 概述

代公众号网页授权是第三方平台代公众号实现OAuth2.0网页授权的功能。WeGo库提供了完整的网页授权实现，支持授权码模式和静默授权模式。

## 授权流程

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Official_Accounts/official_account_website_authorization.html" index="0">0</mcreference>，代公众号网页授权流程分为以下步骤：

### 第一步：请求CODE
引导用户访问授权页面，用户同意授权后，微信会重定向到指定的redirect_uri并携带code参数。

### 第二步：通过code换取access_token
使用授权码code换取网页授权access_token。

### 第三步：刷新access_token（如果需要）
由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新。

### 第四步：拉取用户信息（需授权作用域为snsapi_userinfo）
如果网页授权作用域为snsapi_userinfo，此时可以通过access_token和openid拉取用户信息。

### 授权作用域说明
- **snsapi_base**：静默授权，不弹出授权页面，只能获取用户的openid
- **snsapi_userinfo**：弹出授权页面，可通过openid获取用户基本信息

## wxopen组件实现

### 网页授权客户端

```go
// OAuthClient 网页授权客户端
type OAuthClient struct {
    authorizerClient *AuthorizerClient
    redirectURI      string
}

// 创建OAuth客户端
func (ac *AuthorizerClient) GetOAuthClient(redirectURI string) *OAuthClient {
    return &OAuthClient{
        authorizerClient: ac,
        redirectURI:      redirectURI,
    }
}
```

### 授权URL生成

```go
// 生成授权页面URL
func (oc *OAuthClient) GetAuthorizeURL(scope, state string) string {
    // 验证参数
    if oc.authorizerClient.authorizerAppID == "" {
        panic("authorizerAppID不能为空")
    }
    if oc.redirectURI == "" {
        panic("redirectURI不能为空")
    }
    if scope == "" {
        panic("scope不能为空")
    }

    // 严格按照微信官方文档要求的参数顺序和大小写
    params := url.Values{}
    params.Set("appid", oc.authorizerClient.authorizerAppID)
    params.Set("redirect_uri", oc.redirectURI)
    params.Set("response_type", "code")
    params.Set("scope", scope)
    if state != "" {
        params.Set("state", state)
    }
    params.Set("component_appid", oc.authorizerClient.authClient.client.GetConfig().ComponentAppID)

    // 使用微信官方文档指定的授权URL
    return "https://open.weixin.qq.com/connect/oauth2/authorize?" + params.Encode() + "#wechat_redirect"
}

// 生成静默授权URL
func (oc *OAuthClient) GetBaseAuthorizeURL(state string) string {
    return oc.GetAuthorizeURL("snsapi_base", state)
}

// 生成用户信息授权URL
func (oc *OAuthClient) GetUserInfoAuthorizeURL(state string) string {
    return oc.GetAuthorizeURL("snsapi_userinfo", state)
}
```

### 授权码处理

```go
// 使用授权码获取AccessToken
func (oc *OAuthClient) GetAccessToken(ctx context.Context, code string) (*OAuthToken, error) {
    // 验证参数
    if code == "" {
        return nil, fmt.Errorf("授权码不能为空")
    }
    if oc.authorizerClient.authorizerAppID == "" {
        return nil, fmt.Errorf("授权方AppID不能为空")
    }

    // 需要先获取组件令牌
    componentToken, err := oc.authorizerClient.authClient.client.GetComponentToken(ctx)
    if err != nil {
        return nil, fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }

    // 使用微信官方文档指定的URL
    apiURL := "https://api.weixin.qq.com/sns/oauth2/component/access_token"

    // 严格按照微信官方文档要求的参数格式
    params := map[string]interface{}{
        "appid":                  oc.authorizerClient.authorizerAppID,
        "code":                   code,
        "grant_type":             "authorization_code",
        "component_appid":        oc.authorizerClient.authClient.client.GetConfig().ComponentAppID,
        "component_access_token": componentToken.AccessToken,
    }

    var oauthToken OAuthToken
    err = oc.authorizerClient.authClient.client.MakeRequest(ctx, "POST", apiURL, params, &oauthToken)
    if err != nil {
        return nil, err
    }

    if !oauthToken.IsSuccess() {
        return nil, &oauthToken.APIResponse
    }

    return &oauthToken, nil
}
```

### 用户信息获取

```go
// 获取用户信息
func (oc *OAuthClient) GetUserInfo(ctx context.Context, accessToken, openID string) (*OAuthUserInfo, error) {
    // 验证参数
    if accessToken == "" {
        return nil, fmt.Errorf("accessToken不能为空")
    }
    if openID == "" {
        return nil, fmt.Errorf("openID不能为空")
    }

    // 使用微信官方文档指定的URL
    apiURL := "https://api.weixin.qq.com/sns/userinfo"

    // 严格按照微信官方文档要求的参数格式
    params := map[string]interface{}{
        "access_token": accessToken,
        "openid":       openID,
        "lang":         "zh_CN",
    }

    var userInfo OAuthUserInfo
    err := oc.authorizerClient.authClient.client.MakeRequest(ctx, "GET", apiURL, params, &userInfo)
    if err != nil {
        return nil, err
    }

    if !userInfo.IsSuccess() {
        return nil, &userInfo.APIResponse
    }

    return &userInfo, nil
}

// 刷新AccessToken
func (oc *OAuthClient) RefreshToken(ctx context.Context, refreshToken string) (*OAuthToken, error) {
    // 验证参数
    if refreshToken == "" {
        return nil, fmt.Errorf("refreshToken不能为空")
    }
    if oc.authorizerClient.authorizerAppID == "" {
        return nil, fmt.Errorf("授权方AppID不能为空")
    }

    // 需要先获取组件令牌
    componentToken, err := oc.authorizerClient.authClient.client.GetComponentToken(ctx)
    if err != nil {
        return nil, fmt.Errorf("获取ComponentAccessToken失败: %v", err)
    }

    // 使用微信官方文档指定的URL
    apiURL := "https://api.weixin.qq.com/sns/oauth2/component/refresh_token"

    // 严格按照微信官方文档要求的参数格式
    params := map[string]interface{}{
        "appid":                  oc.authorizerClient.authorizerAppID,
        "grant_type":             "refresh_token",
        "refresh_token":          refreshToken,
        "component_appid":        oc.authorizerClient.authClient.client.GetConfig().ComponentAppID,
        "component_access_token": componentToken.AccessToken,
    }

    var oauthToken OAuthToken
    err = oc.authorizerClient.authClient.client.MakeRequest(ctx, "POST", apiURL, params, &oauthToken)
    if err != nil {
        return nil, err
    }

    if !oauthToken.IsSuccess() {
        return nil, &oauthToken.APIResponse
    }

    return &oauthToken, nil
}
```

## 完整示例

### 1. 网页授权示例

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "github.com/jcbowen/wego"
)

func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // 授权方信息
    authorizerAppID := "授权方AppID"
    redirectURI := "https://yourdomain.com/oauth/callback"
    
    // 获取授权方客户端
    authorizerClient := client.GetAuthorizerClient(authorizerAppID)
    
    // 获取OAuth客户端
    oauthClient := authorizerClient.GetOAuthClient(redirectURI)
    
    // HTTP路由设置
    http.HandleFunc("/oauth/authorize", func(w http.ResponseWriter, r *http.Request) {
        // 生成授权URL
        authURL := oauthClient.GetUserInfoAuthorizeURL("your_state")
        
        // 重定向到授权页面
        http.Redirect(w, r, authURL, http.StatusFound)
    })
    
    http.HandleFunc("/oauth/callback", func(w http.ResponseWriter, r *http.Request) {
        ctx := context.Background()
        
        // 获取授权码
        code := r.URL.Query().Get("code")
        state := r.URL.Query().Get("state")
        
        if code == "" {
            http.Error(w, "授权码不能为空", http.StatusBadRequest)
            return
        }
        
        // 验证state参数（防止CSRF攻击）
        if state != "your_state" {
            http.Error(w, "State参数不匹配", http.StatusBadRequest)
            return
        }
        
        // 使用授权码获取AccessToken
        oauthToken, err := oauthClient.GetAccessToken(ctx, code)
        if err != nil {
            http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 获取用户信息
        userInfo, err := oauthClient.GetUserInfo(ctx, oauthToken.AccessToken, oauthToken.OpenID)
        if err != nil {
            http.Error(w, "获取用户信息失败: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 显示用户信息
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprintf(w, `
            <h1>授权成功</h1>
            <p>昵称: %s</p>
            <p>头像: <img src="%s" width="100"></p>
            <p>性别: %s</p>
            <p>城市: %s</p>
            <p>国家: %s</p>
            <p>AccessToken: %s</p>
            <p>RefreshToken: %s</p>
            <p>有效期: %d秒</p>
        `, userInfo.Nickname, userInfo.HeadImgURL, userInfo.Sex, userInfo.City, userInfo.Country, 
           oauthToken.AccessToken, oauthToken.RefreshToken, oauthToken.ExpiresIn)
    })
    
    fmt.Println("OAuth服务启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 2. 静默授权示例

```go
// 静默授权（只获取OpenID）
func handleSilentAuth(oauthClient *wego.OAuthClient, w http.ResponseWriter, r *http.Request) {
    // 生成静默授权URL
    authURL := oauthClient.GetBaseAuthorizeURL("silent_state")
    
    // 重定向到授权页面
    http.Redirect(w, r, authURL, http.StatusFound)
}

func handleSilentCallback(oauthClient *wego.OAuthClient, w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
    code := r.URL.Query().Get("code")
    
    if code == "" {
        http.Error(w, "授权码不能为空", http.StatusBadRequest)
        return
    }
    
    // 使用授权码获取AccessToken（只能获取OpenID）
    oauthToken, err := oauthClient.GetAccessToken(ctx, code)
    if err != nil {
        http.Error(w, "获取AccessToken失败: "+err.Error(), http.StatusInternalServerError)
        return
    }
    
    // 静默授权只能获取OpenID，不能获取用户详细信息
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprintf(w, `
        <h1>静默授权成功</h1>
        <p>OpenID: %s</p>
        <p>注意：静默授权只能获取OpenID，无法获取用户详细信息</p>
    `, oauthToken.OpenID)
}
```

### 3. RefreshToken使用示例

```go
// 刷新AccessToken示例
func handleRefreshToken(oauthClient *wego.OAuthClient, w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
    
    // 从存储中获取之前的RefreshToken（这里简化处理）
    refreshToken := r.URL.Query().Get("refresh_token")
    if refreshToken == "" {
        http.Error(w, "RefreshToken不能为空", http.StatusBadRequest)
        return
    }
    
    // 使用RefreshToken刷新AccessToken
    newOAuthToken, err := oauthClient.RefreshToken(ctx, refreshToken)
    if err != nil {
        http.Error(w, "刷新AccessToken失败: "+err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprintf(w, `
        <h1>Token刷新成功</h1>
        <p>新的AccessToken: %s</p>
        <p>新的RefreshToken: %s</p>
        <p>有效期: %d秒</p>
        <p>OpenID: %s</p>
    `, newOAuthToken.AccessToken, newOAuthToken.RefreshToken, 
       newOAuthToken.ExpiresIn, newOAuthToken.OpenID)
}
```

## 安全考虑

### 1. State参数防CSRF

```go
// 生成安全的State参数
func generateSecureState() string {
    // 使用加密随机数生成State
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        panic(err)
    }
    
    return base64.URLEncoding.EncodeToString(bytes)
}

// 验证State参数
func validateState(receivedState, expectedState string) bool {
    // 简单的字符串比较（实际应用中可能需要更复杂的验证）
    return receivedState == expectedState
}
```

### 2. Token安全存储

```go
// 安全的Token存储
func safeStoreOAuthToken(sessionID string, token *wego.OAuthToken) error {
    // 加密存储Token
    encryptedToken, err := encryptToken(token)
    if err != nil {
        return err
    }
    
    // 存储到安全的存储介质（如Redis、数据库）
    err = storage.Set(sessionID, encryptedToken, token.ExpiresIn)
    if err != nil {
        return err
    }
    
    return nil
}

// 安全的Token获取
func safeGetOAuthToken(sessionID string) (*wego.OAuthToken, error) {
    encryptedToken, err := storage.Get(sessionID)
    if err != nil {
        return nil, err
    }
    
    token, err := decryptToken(encryptedToken)
    if err != nil {
        return nil, err
    }
    
    return token, nil
}
```

## 最佳实践

### 1. 会话管理
- 使用安全的Session管理
- 设置合理的Session过期时间
- 实现Session清理机制

### 2. 错误处理
- 完善的错误页面
- 用户友好的错误提示
- 错误日志记录

### 3. 性能优化
- Token缓存减少API调用
- 连接池提高性能
- 异步处理耗时操作

### 4. 用户体验
- 清晰的授权说明
- 流畅的授权流程
- 授权失败的重试机制

## 注意事项

### 1. 授权范围
- snsapi_base：静默授权，只获取OpenID
- snsapi_userinfo：需要用户确认，获取完整用户信息
- 根据业务需求选择合适的授权范围

### 2. 频率限制
- 网页授权有调用频率限制
- 避免频繁的授权请求
- 实现合理的缓存策略

### 3. 安全性
- 使用HTTPS保护通信安全
- 验证所有输入参数
- 防止重放攻击

## 常见问题

### Q: 授权页面显示"redirect_uri参数错误"
A: 检查授权回调域名配置、redirect_uri参数格式

### Q: 获取AccessToken失败
A: 检查授权码是否有效、ComponentAccessToken是否正确

### Q: 获取用户信息失败
A: 检查授权范围是否为snsapi_userinfo、AccessToken是否有效

通过wxopen组件的网页授权功能，您可以轻松实现公众号的OAuth2.0授权，为用户提供安全的第三方登录体验。