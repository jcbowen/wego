# 08-代调用接口

## 概述

代调用接口是第三方平台代公众号或小程序调用微信API的核心功能。WeGo库提供了完整的API封装，支持所有微信开放平台接口的调用。

## API调用基础

### 核心API客户端

```go
// APIClient API客户端
type APIClient struct {
    client *WegoClient
}

// 创建API客户端
func NewAPIClient(client *WegoClient) *APIClient {
    return &APIClient{
        client: client,
    }
}
```

### 通用API调用方法

```go
// MakeRequest 发起API请求
func (c *APIClient) MakeRequest(ctx context.Context, method, url string, params interface{}, result interface{}) error {
    // 1. 获取合适的Token
    token, err := c.getTokenForAPI(url)
    if err != nil {
        return err
    }
    
    // 2. 构建请求
    req, err := c.buildRequest(method, url, params, token)
    if err != nil {
        return err
    }
    
    // 3. 发送请求
    resp, err := c.client.httpClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // 4. 解析响应
    return c.parseResponse(resp, result)
}
```

## 代公众号调用接口

### 1. 客服消息接口

```go
// SendCustomMessage 发送客服消息
func (c *APIClient) SendCustomMessage(ctx context.Context, authorizerAppID string, message *CustomMessage) error {
    // 获取授权方AccessToken
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=%s", token)
    
    var result APIResponse
    err = c.MakeRequest(ctx, "POST", url, message, &result)
    if err != nil {
        return err
    }
    
    if !result.IsSuccess() {
        return &result
    }
    
    return nil
}

// CustomMessage 客服消息结构体
type CustomMessage struct {
    ToUser  string      `json:"touser"`
    MsgType string      `json:"msgtype"`
    Text    *TextMsg    `json:"text,omitempty"`
    Image   *ImageMsg   `json:"image,omitempty"`
    Voice   *VoiceMsg   `json:"voice,omitempty"`
    Video   *VideoMsg   `json:"video,omitempty"`
    Music   *MusicMsg   `json:"music,omitempty"`
    News    *NewsMsg    `json:"news,omitempty"`
    MPNews  *MPNewsMsg  `json:"mpnews,omitempty"`
    WXCard  *WXCardMsg  `json:"wxcard,omitempty"`
    MiniProgramPage *MiniProgramPageMsg `json:"miniprogrampage,omitempty"`
}
```

### 2. 菜单管理接口

```go
// CreateMenu 创建自定义菜单
func (c *APIClient) CreateMenu(ctx context.Context, authorizerAppID string, menu *Menu) error {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/menu/create?access_token=%s", token)
    
    var result APIResponse
    err = c.MakeRequest(ctx, "POST", url, menu, &result)
    if err != nil {
        return err
    }
    
    if !result.IsSuccess() {
        return &result
    }
    
    return nil
}

// GetMenu 获取菜单
func (c *APIClient) GetMenu(ctx context.Context, authorizerAppID string) (*Menu, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/menu/get?access_token=%s", token)
    
    var result struct {
        APIResponse
        Menu *Menu `json:"menu"`
        ConditionalMenu []*ConditionalMenu `json:"conditionalmenu"`
    }
    
    err = c.MakeRequest(ctx, "GET", url, nil, &result)
    if err != nil {
        return nil, err
    }
    
    if !result.IsSuccess() {
        return nil, &result.APIResponse
    }
    
    return result.Menu, nil
}
```

### 3. 用户管理接口

```go
// GetUserInfo 获取用户信息
func (c *APIClient) GetUserInfo(ctx context.Context, authorizerAppID, openID string) (*UserInfo, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/user/info?access_token=%s&openid=%s&lang=zh_CN", token, openID)
    
    var result UserInfo
    err = c.MakeRequest(ctx, "GET", url, nil, &result)
    if err != nil {
        return nil, err
    }
    
    return &result, nil
}

// BatchGetUserInfo 批量获取用户信息
func (c *APIClient) BatchGetUserInfo(ctx context.Context, authorizerAppID string, openIDs []string) ([]*UserInfo, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token=%s", token)
    
    request := struct {
        UserList []struct {
            OpenID string `json:"openid"`
            Lang   string `json:"lang"`
        } `json:"user_list"`
    }{
        UserList: make([]struct {
            OpenID string `json:"openid"`
            Lang   string `json:"lang"`
        }, len(openIDs)),
    }
    
    for i, openID := range openIDs {
        request.UserList[i] = struct {
            OpenID string `json:"openid"`
            Lang   string `json:"lang"`
        }{
            OpenID: openID,
            Lang:   "zh_CN",
        }
    }
    
    var result struct {
        APIResponse
        UserInfoList []*UserInfo `json:"user_info_list"`
    }
    
    err = c.MakeRequest(ctx, "POST", url, request, &result)
    if err != nil {
        return nil, err
    }
    
    if !result.IsSuccess() {
        return nil, &result.APIResponse
    }
    
    return result.UserInfoList, nil
}
```

### 4. 素材管理接口

```go
// UploadMedia 上传临时素材
func (c *APIClient) UploadMedia(ctx context.Context, authorizerAppID, mediaType string, file io.Reader, filename string) (*MediaUploadResult, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/media/upload?access_token=%s&type=%s", token, mediaType)
    
    var result MediaUploadResult
    err = c.uploadFile(ctx, url, file, filename, &result)
    if err != nil {
        return nil, err
    }
    
    return &result, nil
}

// GetMedia 获取临时素材
func (c *APIClient) GetMedia(ctx context.Context, authorizerAppID, mediaID string) (io.ReadCloser, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/media/get?access_token=%s&media_id=%s", token, mediaID)
    
    resp, err := c.client.httpClient.Get(url)
    if err != nil {
        return nil, err
    }
    
    return resp.Body, nil
}
```

## 代小程序调用接口

### 1. 小程序码接口

```go
// CreateWXACode 创建小程序码
func (c *APIClient) CreateWXACode(ctx context.Context, authorizerAppID string, params *WXACodeParams) (io.ReadCloser, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/wxa/getwxacode?access_token=%s", token)
    
    resp, err := c.client.httpClient.Post(url, "application/json", strings.NewReader(params.ToJSON()))
    if err != nil {
        return nil, err
    }
    
    return resp.Body, nil
}

// CreateWXACodeUnlimited 创建无限量小程序码
func (c *APIClient) CreateWXACodeUnlimited(ctx context.Context, authorizerAppID string, params *WXACodeUnlimitedParams) (io.ReadCloser, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=%s", token)
    
    resp, err := c.client.httpClient.Post(url, "application/json", strings.NewReader(params.ToJSON()))
    if err != nil {
        return nil, err
    }
    
    return resp.Body, nil
}
```

### 2. 模板消息接口

```go
// SendTemplateMessage 发送模板消息
func (c *APIClient) SendTemplateMessage(ctx context.Context, authorizerAppID string, message *TemplateMessage) (int64, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return 0, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s", token)
    
    var result struct {
        APIResponse
        MsgID int64 `json:"msgid"`
    }
    
    err = c.MakeRequest(ctx, "POST", url, message, &result)
    if err != nil {
        return 0, err
    }
    
    if !result.IsSuccess() {
        return 0, &result.APIResponse
    }
    
    return result.MsgID, nil
}
```

## 第三方平台自身接口

### 1. 获取预授权码

```go
// GetPreAuthCode 获取预授权码
func (c *APIClient) GetPreAuthCode(ctx context.Context) (*PreAuthCode, error) {
    token, err := c.client.GetComponentAccessToken(ctx)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/component/api_create_preauthcode?access_token=%s", token)
    
    request := PreAuthCodeRequest{
        ComponentAppID: c.client.GetConfig().ComponentAppID,
    }
    
    var result PreAuthCodeResponse
    err = c.MakeRequest(ctx, "POST", url, request, &result)
    if err != nil {
        return nil, err
    }
    
    if !result.IsSuccess() {
        return nil, &result.APIResponse
    }
    
    return &PreAuthCode{
        PreAuthCode: result.PreAuthCode,
        ExpiresIn:   result.ExpiresIn,
        CreatedAt:  time.Now(),
    }, nil
}
```

### 2. 使用授权码获取授权信息

```go
// QueryAuth 使用授权码换取授权信息
func (c *APIClient) QueryAuth(ctx context.Context, authCode string) (*AuthorizationInfo, error) {
    token, err := c.client.GetComponentAccessToken(ctx)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/component/api_query_auth?access_token=%s", token)
    
    request := QueryAuthRequest{
        ComponentAppID: c.client.GetConfig().ComponentAppID,
        AuthorizationCode: authCode,
    }
    
    var result QueryAuthResponse
    err = c.MakeRequest(ctx, "POST", url, request, &result)
    if err != nil {
        return nil, err
    }
    
    if !result.IsSuccess() {
        return nil, &result.APIResponse
    }
    
    return &result.AuthorizationInfo, nil
}
```

### 3. 获取授权方信息

```go
// GetAuthorizerInfo 获取授权方信息
func (c *APIClient) GetAuthorizerInfo(ctx context.Context, authorizerAppID string) (*AuthorizerInfo, error) {
    token, err := c.client.GetComponentAccessToken(ctx)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/component/api_get_authorizer_info?access_token=%s", token)
    
    request := GetAuthorizerInfoRequest{
        ComponentAppID: c.client.GetConfig().ComponentAppID,
        AuthorizerAppID: authorizerAppID,
    }
    
    var result GetAuthorizerInfoResponse
    err = c.MakeRequest(ctx, "POST", url, request, &result)
    if err != nil {
        return nil, err
    }
    
    if !result.IsSuccess() {
        return nil, &result.APIResponse
    }
    
    return &result.AuthorizerInfo, nil
}
```

## 高级功能

### 1. 批量API调用

```go
// BatchAPIRequest 批量API请求
type BatchAPIRequest struct {
    Requests []*SingleAPIRequest `json:"requests"`
}

// SingleAPIRequest 单个API请求
type SingleAPIRequest struct {
    Method string `json:"method"`
    URL    string `json:"url"`
    Body   string `json:"body"`
}

// BatchAPIResponse 批量API响应
type BatchAPIResponse struct {
    Responses []*SingleAPIResponse `json:"responses"`
}

// BatchCall 批量调用API
func (c *APIClient) BatchCall(ctx context.Context, authorizerAppID string, requests *BatchAPIRequest) (*BatchAPIResponse, error) {
    token, err := c.client.GetAuthorizerAccessToken(ctx, authorizerAppID)
    if err != nil {
        return nil, err
    }
    
    url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/batch/invoke?access_token=%s", token)
    
    var result BatchAPIResponse
    err = c.MakeRequest(ctx, "POST", url, requests, &result)
    if err != nil {
        return nil, err
    }
    
    return &result, nil
}
```

### 2. 异步API调用

```go
// AsyncAPICall 异步API调用
func (c *APIClient) AsyncAPICall(ctx context.Context, authorizerAppID, method, url string, params interface{}) <-chan *AsyncAPIResult {
    resultChan := make(chan *AsyncAPIResult, 1)
    
    go func() {
        defer close(resultChan)
        
        var result interface{}
        err := c.MakeRequest(ctx, method, url, params, &result)
        
        resultChan <- &AsyncAPIResult{
            Result: result,
            Error:  err,
        }
    }()
    
    return resultChan
}
```

## 错误处理

### 1. 错误重试机制

```go
// MakeRequestWithRetry 带重试的API请求
func (c *APIClient) MakeRequestWithRetry(ctx context.Context, method, url string, params interface{}, result interface{}, maxRetries int) error {
    var lastErr error
    
    for i := 0; i <= maxRetries; i++ {
        err := c.MakeRequest(ctx, method, url, params, result)
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // 检查是否为可重试错误
        if !c.isRetryableError(err) {
            return err
        }
        
        // 等待一段时间后重试
        time.Sleep(time.Duration(i+1) * time.Second)
    }
    
    return lastErr
}

// 可重试的错误类型
func (c *APIClient) isRetryableError(err error) bool {
    if apiErr, ok := err.(*APIError); ok {
        switch apiErr.ErrCode {
        case -1, 42001, 44001, 45001: // 系统繁忙、token过期、访问频次超限
            return true
        }
    }
    
    // 网络错误也可以重试
    if _, ok := err.(*url.Error); ok {
        return true
    }
    
    return false
}
```

## 使用示例

### 1. 发送客服消息

```go
func main() {
    config := &wego.WeGoConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWeGo(config)
    
    // 创建授权方客户端
    authorizerClient := client.GetAuthorizerClient("authorizer_appid")
    
    // 发送文本消息
    message := &wego.CustomMessage{
        ToUser: "user_openid",
        MsgType: "text",
        Text: &wego.TextMsg{
            Content: "Hello, World!",
        },
    }
    
    err := authorizerClient.SendCustomMessage(context.Background(), message)
    if err != nil {
        log.Printf("发送消息失败: %v", err)
        return
    }
    
    log.Println("消息发送成功")
}
```

### 2. 批量获取用户信息

```go
func batchGetUserInfo(client *wego.WegoClient, authorizerAppID string, openIDs []string) {
    userInfos, err := client.BatchGetUserInfo(context.Background(), authorizerAppID, openIDs)
    if err != nil {
        log.Printf("批量获取用户信息失败: %v", err)
        return
    }
    
    for _, userInfo := range userInfos {
        fmt.Printf("用户: %s, 昵称: %s\n", userInfo.OpenID, userInfo.Nickname)
    }
}
```

## 总结

WeGo库提供了完整的代调用接口实现，支持所有微信开放平台API的调用。通过统一的API客户端和自动化的Token管理，开发者可以轻松实现第三方平台的各种功能需求。