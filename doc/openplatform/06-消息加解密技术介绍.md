# 06-消息加解密技术介绍

## 概述

本文档详细介绍了微信开放平台消息加解密的技术实现细节，包括加密算法、协议格式、安全考虑等。wego库完整实现了微信官方技术规范。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference><mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>

## 技术架构（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>

### 1. 加密算法
- **AES-256-CBC**：对称加密算法，256位密钥长度，使用PKCS7填充
- **SHA1**：消息签名算法，参数顺序：token、timestamp、nonce、msg_encrypt
- **Base64**：编码格式，用于AES密钥和加密消息

### 2. 密钥管理
- **EncodingAESKey**：43位Base64编码的AES密钥（当前使用）
- **PrevEncodingAESKey**：上一次的EncodingAESKey（支持密钥轮换）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="0">0</mcreference>
- **Token**：消息验证令牌
- **AppID**：应用标识

## 详细技术实现

### 1. AES加密解密

```go
// AES加密实现（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>
func EncryptMsg(plainText, appID string, aesKey []byte) (string, error) {
    // 生成16字节的安全随机字符串
    randomStr, err := generateRandomString(16)
    if err != nil {
        return "", fmt.Errorf("生成随机字符串失败: %v", err)
    }

    // 构造待加密的明文：random(16B) + msg_len(4B) + msg + appid
    text := fmt.Sprintf("%s%s%s%s",
        randomStr,
        intToNetworkBytesOrder(len(plainText)),
        plainText,
        appID)

    // PKCS7填充
    blockSize := aes.BlockSize
    textBytes := []byte(text)
    padLen := blockSize - len(textBytes)%blockSize
    if padLen == 0 {
        padLen = blockSize
    }
    padText := bytes.Repeat([]byte{byte(padLen)}, padLen)
    textBytes = append(textBytes, padText...)

    // AES加密（CBC模式，使用aesKey的前16字节作为IV）
    block, err := aes.NewCipher(aesKey)
    if err != nil {
        return "", fmt.Errorf("创建AES密码器失败: %v", err)
    }

    cipherText := make([]byte, len(textBytes))
    mode := cipher.NewCBCEncrypter(block, aesKey[:aes.BlockSize])
    mode.CryptBlocks(cipherText, textBytes)

    // Base64编码
    return base64.StdEncoding.EncodeToString(cipherText), nil
}

// AES解密实现（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>
func DecryptMsg(encryptedMsg string, aesKey []byte) (string, error) {
    // Base64解码
    cipherText, err := base64.StdEncoding.DecodeString(encryptedMsg)
    if err != nil {
        return "", fmt.Errorf("Base64解码失败: %v", err)
    }

    // AES解密（CBC模式，使用aesKey的前16字节作为IV）
    block, err := aes.NewCipher(aesKey)
    if err != nil {
        return "", fmt.Errorf("创建AES密码器失败: %v", err)
    }

    if len(cipherText) < aes.BlockSize {
        return "", errors.New("密文长度过短")
    }

    plainText := make([]byte, len(cipherText))
    mode := cipher.NewCBCDecrypter(block, aesKey[:aes.BlockSize])
    mode.CryptBlocks(plainText, cipherText)

    // PKCS7去填充
    if len(plainText) == 0 {
        return "", errors.New("解密后数据为空")
    }
    padLen := int(plainText[len(plainText)-1])
    if padLen < 1 || padLen > aes.BlockSize {
        return "", errors.New("填充数据无效")
    }

    plainText = plainText[:len(plainText)-padLen]

    // 解析消息结构：random(16字节) + msg_len(4字节) + msg + appid
    if len(plainText) < 20 {
        return "", errors.New("明文长度过短")
    }

    msgLen := networkBytesOrderToInt(plainText[16:20])
    if len(plainText) < 20+msgLen {
        return "", errors.New("消息长度无效")
    }

    // 验证AppID
    decryptedAppID := string(plainText[20+msgLen:])
    if len(decryptedAppID) == 0 {
        return "", errors.New("AppID缺失")
    }

    return string(plainText[20 : 20+msgLen]), nil
}
```

### 2. PKCS7填充（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>

PKCS7填充在AES加密解密过程中自动处理，具体实现如下：

```go
// PKCS7填充（在EncryptMsg函数中实现）
blockSize := aes.BlockSize
textBytes := []byte(text)
padLen := blockSize - len(textBytes)%blockSize
if padLen == 0 {
    padLen = blockSize
}
padText := bytes.Repeat([]byte{byte(padLen)}, padLen)
textBytes = append(textBytes, padText...)

// PKCS7去填充（在DecryptMsg函数中实现）
if len(plainText) == 0 {
    return "", errors.New("解密后数据为空")
}
padLen := int(plainText[len(plainText)-1])
if padLen < 1 || padLen > aes.BlockSize {
    return "", errors.New("填充数据无效")
}
plainText = plainText[:len(plainText)-padLen]
```

### 3. 消息格式解析（符合微信官方规范）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>

解密后的消息格式为：
```
random(16字节) + msg_len(4字节) + msg + appid
```

- **random**：16字节随机字符串
- **msg_len**：4字节网络字节序的消息长度
- **msg**：实际消息内容
- **appid**：应用标识（必须验证正确性）

消息格式解析在DecryptMsg函数中自动处理：

```go
// 解析消息结构：random(16字节) + msg_len(4字节) + msg + appid
if len(plainText) < 20 {
    return "", errors.New("明文长度过短")
}

msgLen := networkBytesOrderToInt(plainText[16:20])
if len(plainText) < 20+msgLen {
    return "", errors.New("消息长度无效")
}

// 验证AppID（微信官方要求验证第三方平台AppID）<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Technical_Plan.html" index="1">1</mcreference>
decryptedAppID := string(plainText[20+msgLen:])
if len(decryptedAppID) == 0 {
    return "", errors.New("AppID缺失")
}

return string(plainText[20 : 20+msgLen]), nil
```

## 安全考虑

### 1. 重放攻击防护

```go
// 时间戳验证
func validateTimestamp(timestamp string, maxAge time.Duration) bool {
    ts, err := strconv.ParseInt(timestamp, 10, 64)
    if err != nil {
        return false
    }
    
    messageTime := time.Unix(ts, 0)
    now := time.Now()
    
    return now.Sub(messageTime) <= maxAge
}

// 使用示例
func safeDecrypt(msgSignature, timestamp, nonce, encryptedMsg string) ([]byte, error) {
    // 验证时间戳（5分钟内有效）
    if !validateTimestamp(timestamp, 5*time.Minute) {
        return nil, fmt.Errorf("消息已过期")
    }
    
    // 验证签名
    if !validateSignature(token, timestamp, nonce, encryptedMsg, msgSignature) {
        return nil, fmt.Errorf("签名验证失败")
    }
    
    return crypto.DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg)
}
```

### 2. 随机数管理

```go
// 安全的随机数生成
import "crypto/rand"

func generateRandomString(length int) (string, error) {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    
    const letters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    for i, b := range bytes {
        bytes[i] = letters[b%byte(len(letters))]
    }
    
    return string(bytes), nil
}
```

## 性能优化

### 1. 缓存优化

```go
// 加解密实例缓存
type CryptoCache struct {
    cache map[string]*WXBizMsgCrypt
    mutex sync.RWMutex
}

func (c *CryptoCache) Get(appID string) *WXBizMsgCrypt {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    if crypto, exists := c.cache[appID]; exists {
        return crypto
    }
    return nil
}

func (c *CryptoCache) Set(appID string, crypto *WXBizMsgCrypt) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.cache[appID] = crypto
}
```

### 2. 批量处理

```go
// 批量消息处理
func batchProcessMessages(messages []*EncryptedMessage) ([]*DecryptedMessage, error) {
    var wg sync.WaitGroup
    results := make([]*DecryptedMessage, len(messages))
    errors := make([]error, len(messages))
    
    for i, msg := range messages {
        wg.Add(1)
        go func(index int, m *EncryptedMessage) {
            defer wg.Done()
            
            decrypted, err := crypto.DecryptMsg(
                m.Signature, 
                m.Timestamp, 
                m.Nonce, 
                m.EncryptedMsg,
            )
            
            if err != nil {
                errors[index] = err
                return
            }
            
            results[index] = &DecryptedMessage{
                Index:   index,
                Content: string(decrypted),
            }
        }(i, msg)
    }
    
    wg.Wait()
    
    // 检查错误
    for _, err := range errors {
        if err != nil {
            return nil, fmt.Errorf("批量处理失败: %v", err)
        }
    }
    
    return results, nil
}
```

## 测试用例

### 1. 单元测试

```go
func TestEncryptDecrypt(t *testing.T) {
    crypto := NewWXBizMsgCrypt("test_token", "test_encoding_aes_key", "test_app_id")
    
    // 测试消息
    testMsg := "Hello, World!"
    timestamp := "1234567890"
    nonce := "test_nonce"
    
    // 加密
    encrypted, err := crypto.EncryptMsg(testMsg, timestamp, nonce)
    if err != nil {
        t.Fatalf("加密失败: %v", err)
    }
    
    // 提取签名和加密内容
    signature := extractSignature(encrypted)
    encryptedMsg := extractEncryptedMsg(encrypted)
    
    // 解密
    decrypted, err := crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    if err != nil {
        t.Fatalf("解密失败: %v", err)
    }
    
    if string(decrypted) != testMsg {
        t.Errorf("解密结果不匹配: 期望 %s, 实际 %s", testMsg, string(decrypted))
    }
}
```

### 2. 性能测试

```go
func BenchmarkEncryptDecrypt(b *testing.B) {
    crypto := NewWXBizMsgCrypt("test_token", "test_encoding_aes_key", "test_app_id")
    
    for i := 0; i < b.N; i++ {
        testMsg := fmt.Sprintf("Message %d", i)
        timestamp := fmt.Sprintf("%d", time.Now().Unix())
        nonce := generateRandomStr(16)
        
        encrypted, _ := crypto.EncryptMsg(testMsg, timestamp, nonce)
        
        signature := extractSignature(encrypted)
        encryptedMsg := extractEncryptedMsg(encrypted)
        
        crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    }
}
```

## 故障排除

### 1. 常见错误

```go
// 错误处理函数
func handleCryptoError(err error) {
    switch {
    case strings.Contains(err.Error(), "签名验证失败"):
        log.Println("请检查Token配置")
    case strings.Contains(err.Error(), "解密失败"):
        log.Println("请检查EncodingAESKey配置")
    case strings.Contains(err.Error(), "AppID不匹配"):
        log.Println("请检查AppID配置")
    case strings.Contains(err.Error(), "消息已过期"):
        log.Println("请检查系统时间同步")
    default:
        log.Printf("未知错误: %v", err)
    }
}
```

### 2. 调试工具

```go
// 调试模式
func debugDecrypt(msgSignature, timestamp, nonce, encryptedMsg string) {
    fmt.Printf("调试信息:\n")
    fmt.Printf("签名: %s\n", msgSignature)
    fmt.Printf("时间戳: %s\n", timestamp) 
    fmt.Printf("随机数: %s\n", nonce)
    fmt.Printf("加密消息长度: %d\n", len(encryptedMsg))
    
    // 计算期望签名
    expected := genSignature(token, timestamp, nonce, encryptedMsg)
    fmt.Printf("期望签名: %s\n", expected)
    fmt.Printf("签名匹配: %v\n", msgSignature == expected)
}
```

## 总结

wxopen组件的消息加解密实现完全符合微信开放平台的技术规范，提供了安全、高效、可靠的加解密功能。通过本技术介绍，您可以深入理解加解密的实现原理，并根据实际需求进行定制和优化。