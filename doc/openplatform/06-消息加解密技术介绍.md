# 07-消息加解密技术介绍

## 概述

本文档详细介绍了微信开放平台消息加解密的技术实现细节，包括加密算法、协议格式、安全考虑等。wxopen组件完整实现了这些技术规范。

## 技术架构

### 1. 加密算法
- **AES-256-CBC**：核心加密算法
- **SHA1**：签名算法
- **Base64**：编码格式

### 2. 密钥管理
- **EncodingAESKey**：43位Base64编码密钥
- **Token**：消息验证Token
- **AppID**：应用标识

## 详细技术实现

### 1. AES加密解密

```go
// AES加密实现
func aesEncrypt(plainText []byte, aesKey []byte) ([]byte, error) {
    block, err := aes.NewCipher(aesKey)
    if err != nil {
        return nil, err
    }
    
    // PKCS7填充
    plainText = pkcs7Pad(plainText, block.BlockSize())
    
    // CBC模式加密
    cipherText := make([]byte, len(plainText))
    iv := aesKey[:16] // 使用aesKey前16字节作为IV
    
    mode := cipher.NewCBCEncrypter(block, iv)
    mode.CryptBlocks(cipherText, plainText)
    
    return cipherText, nil
}

// AES解密实现
func aesDecrypt(cipherText []byte, aesKey []byte) ([]byte, error) {
    block, err := aes.NewCipher(aesKey)
    if err != nil {
        return nil, err
    }
    
    // CBC模式解密
    plainText := make([]byte, len(cipherText))
    iv := aesKey[:16]
    
    mode := cipher.NewCBCDecrypter(block, iv)
    mode.CryptBlocks(plainText, cipherText)
    
    // PKCS7去填充
    plainText, err = pkcs7Unpad(plainText, block.BlockSize())
    if err != nil {
        return nil, err
    }
    
    return plainText, nil
}
```

### 2. PKCS7填充

```go
// PKCS7填充
func pkcs7Pad(data []byte, blockSize int) []byte {
    padding := blockSize - len(data)%blockSize
    padText := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(data, padText...)
}

// PKCS7去填充
func pkcs7Unpad(data []byte, blockSize int) ([]byte, error) {
    length := len(data)
    if length == 0 {
        return nil, fmt.Errorf("数据长度不能为0")
    }
    
    padding := int(data[length-1])
    if padding < 1 || padding > blockSize {
        return nil, fmt.Errorf("填充长度无效")
    }
    
    for i := length - padding; i < length; i++ {
        if int(data[i]) != padding {
            return nil, fmt.Errorf("填充数据无效")
        }
    }
    
    return data[:length-padding], nil
}
```

### 3. 消息格式解析

```go
// 解析解密后的数据
func parseDecryptedData(decrypted []byte) (randomStr string, msgLen int, msg []byte, appID string, err error) {
    if len(decrypted) < 16 {
        err = fmt.Errorf("解密数据长度不足")
        return
    }
    
    // 提取16位随机字符串
    randomStr = string(decrypted[:16])
    
    // 解析消息长度（4字节网络字节序）
    msgLenBuf := decrypted[16:20]
    msgLen = int(binary.BigEndian.Uint32(msgLenBuf))
    
    // 验证消息长度
    if len(decrypted) < 20+msgLen {
        err = fmt.Errorf("消息长度不匹配")
        return
    }
    
    // 提取消息内容
    msg = decrypted[20 : 20+msgLen]
    
    // 提取AppID
    appID = string(decrypted[20+msgLen:])
    
    return
}
```

## 安全考虑

### 1. 重放攻击防护

```go
// 时间戳验证
func validateTimestamp(timestamp string, maxAge time.Duration) bool {
    ts, err := strconv.ParseInt(timestamp, 10, 64)
    if err != nil {
        return false
    }
    
    messageTime := time.Unix(ts, 0)
    now := time.Now()
    
    return now.Sub(messageTime) <= maxAge
}

// 使用示例
func safeDecrypt(msgSignature, timestamp, nonce, encryptedMsg string) ([]byte, error) {
    // 验证时间戳（5分钟内有效）
    if !validateTimestamp(timestamp, 5*time.Minute) {
        return nil, fmt.Errorf("消息已过期")
    }
    
    // 验证签名
    if !validateSignature(token, timestamp, nonce, encryptedMsg, msgSignature) {
        return nil, fmt.Errorf("签名验证失败")
    }
    
    return crypto.DecryptMsg(msgSignature, timestamp, nonce, encryptedMsg)
}
```

### 2. 随机数管理

```go
// 安全的随机数生成
import "crypto/rand"

func generateRandomStr(length int) string {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        panic(err)
    }
    
    const letters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    for i, b := range bytes {
        bytes[i] = letters[b%byte(len(letters))]
    }
    
    return string(bytes)
}
```

## 性能优化

### 1. 缓存优化

```go
// 加解密实例缓存
type CryptoCache struct {
    cache map[string]*WXBizMsgCrypt
    mutex sync.RWMutex
}

func (c *CryptoCache) Get(appID string) *WXBizMsgCrypt {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    if crypto, exists := c.cache[appID]; exists {
        return crypto
    }
    return nil
}

func (c *CryptoCache) Set(appID string, crypto *WXBizMsgCrypt) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.cache[appID] = crypto
}
```

### 2. 批量处理

```go
// 批量消息处理
func batchProcessMessages(messages []*EncryptedMessage) ([]*DecryptedMessage, error) {
    var wg sync.WaitGroup
    results := make([]*DecryptedMessage, len(messages))
    errors := make([]error, len(messages))
    
    for i, msg := range messages {
        wg.Add(1)
        go func(index int, m *EncryptedMessage) {
            defer wg.Done()
            
            decrypted, err := crypto.DecryptMsg(
                m.Signature, 
                m.Timestamp, 
                m.Nonce, 
                m.EncryptedMsg,
            )
            
            if err != nil {
                errors[index] = err
                return
            }
            
            results[index] = &DecryptedMessage{
                Index:   index,
                Content: string(decrypted),
            }
        }(i, msg)
    }
    
    wg.Wait()
    
    // 检查错误
    for _, err := range errors {
        if err != nil {
            return nil, fmt.Errorf("批量处理失败: %v", err)
        }
    }
    
    return results, nil
}
```

## 测试用例

### 1. 单元测试

```go
func TestEncryptDecrypt(t *testing.T) {
    crypto := NewWXBizMsgCrypt("test_token", "test_encoding_aes_key", "test_app_id")
    
    // 测试消息
    testMsg := "Hello, World!"
    timestamp := "1234567890"
    nonce := "test_nonce"
    
    // 加密
    encrypted, err := crypto.EncryptMsg(testMsg, timestamp, nonce)
    if err != nil {
        t.Fatalf("加密失败: %v", err)
    }
    
    // 提取签名和加密内容
    signature := extractSignature(encrypted)
    encryptedMsg := extractEncryptedMsg(encrypted)
    
    // 解密
    decrypted, err := crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    if err != nil {
        t.Fatalf("解密失败: %v", err)
    }
    
    if string(decrypted) != testMsg {
        t.Errorf("解密结果不匹配: 期望 %s, 实际 %s", testMsg, string(decrypted))
    }
}
```

### 2. 性能测试

```go
func BenchmarkEncryptDecrypt(b *testing.B) {
    crypto := NewWXBizMsgCrypt("test_token", "test_encoding_aes_key", "test_app_id")
    
    for i := 0; i < b.N; i++ {
        testMsg := fmt.Sprintf("Message %d", i)
        timestamp := fmt.Sprintf("%d", time.Now().Unix())
        nonce := generateRandomStr(16)
        
        encrypted, _ := crypto.EncryptMsg(testMsg, timestamp, nonce)
        
        signature := extractSignature(encrypted)
        encryptedMsg := extractEncryptedMsg(encrypted)
        
        crypto.DecryptMsg(signature, timestamp, nonce, encryptedMsg)
    }
}
```

## 故障排除

### 1. 常见错误

```go
// 错误处理函数
func handleCryptoError(err error) {
    switch {
    case strings.Contains(err.Error(), "签名验证失败"):
        log.Println("请检查Token配置")
    case strings.Contains(err.Error(), "解密失败"):
        log.Println("请检查EncodingAESKey配置")
    case strings.Contains(err.Error(), "AppID不匹配"):
        log.Println("请检查AppID配置")
    case strings.Contains(err.Error(), "消息已过期"):
        log.Println("请检查系统时间同步")
    default:
        log.Printf("未知错误: %v", err)
    }
}
```

### 2. 调试工具

```go
// 调试模式
func debugDecrypt(msgSignature, timestamp, nonce, encryptedMsg string) {
    fmt.Printf("调试信息:\n")
    fmt.Printf("签名: %s\n", msgSignature)
    fmt.Printf("时间戳: %s\n", timestamp) 
    fmt.Printf("随机数: %s\n", nonce)
    fmt.Printf("加密消息长度: %d\n", len(encryptedMsg))
    
    // 计算期望签名
    expected := genSignature(token, timestamp, nonce, encryptedMsg)
    fmt.Printf("期望签名: %s\n", expected)
    fmt.Printf("签名匹配: %v\n", msgSignature == expected)
}
```

## 总结

wxopen组件的消息加解密实现完全符合微信开放平台的技术规范，提供了安全、高效、可靠的加解密功能。通过本技术介绍，您可以深入理解加解密的实现原理，并根据实际需求进行定制和优化。