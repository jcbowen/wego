# 03-授权变更通知推送

## 概述

授权变更通知推送是微信开放平台在授权状态发生变化时，向第三方平台推送的事件通知。WeGo库提供了完整的事件处理机制，支持多种授权变更事件的接收和处理。

## 事件类型

### 1. 授权成功事件 (authorized)
当公众号/服务号/小程序/微信小店/带货助手/视频号助手对第三方平台进行授权时触发。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

### 2. 取消授权事件 (unauthorized)  
当公众号/服务号/小程序/微信小店/带货助手/视频号助手取消对第三方平台的授权时触发。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

### 3. 授权更新事件 (updateauthorized)
当授权方更新授权时触发。如果更新授权时，授权的权限集没有发生变化，将不会触发授权更新通知。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

## 事件推送格式

### XML格式示例

```xml
<!-- 授权成功事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[authorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>

<!-- 取消授权事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[unauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
</xml>

<!-- 授权更新事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[updateauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>
```

## 事件处理实现

### 事件处理器接口

WeGo库定义了事件处理器接口，支持自定义事件处理逻辑：

```go
// EventHandler 事件处理器接口
type EventHandler interface {
    // 处理授权成功事件
    HandleAuthorized(ctx context.Context, event *AuthorizedEvent) error
    
    // 处理取消授权事件  
    HandleUnauthorized(ctx context.Context, event *UnauthorizedEvent) error
    
    // 处理授权更新事件
    HandleUpdateAuthorized(ctx context.Context, event *UpdateAuthorizedEvent) error
}

// DefaultEventHandler 默认事件处理器
type DefaultEventHandler struct{}

func (h *DefaultEventHandler) HandleAuthorized(ctx context.Context, event *AuthorizedEvent) error {
    fmt.Printf("授权成功: AppID=%s, 授权码=%s\n", 
        event.AuthorizerAppid, event.AuthorizationCode)
    
    // 自动获取授权信息并存储
    // ...
    
    return nil
}

func (h *DefaultEventHandler) HandleUnauthorized(ctx context.Context, event *UnauthorizedEvent) error {
    fmt.Printf("取消授权: AppID=%s\n", event.AuthorizerAppid)
    
    // 清理相关数据
    // ...
    
    return nil
}

func (h *DefaultEventHandler) HandleUpdateAuthorized(ctx context.Context, event *UpdateAuthorizedEvent) error {
    fmt.Printf("授权更新: AppID=%s, 授权码=%s\n",
        event.AuthorizerAppid, event.AuthorizationCode)
    
    // 更新授权信息
    // ...
    
    return nil
}
```

### 事件处理流程

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>，接收POST请求后只需直接返回字符串"success"。以下是推荐的事件处理流程：

```go
// 处理授权变更事件
func HandleAuthorizationEvent(ctx context.Context, event *AuthorizationEvent) (string, error) {
    // 验证事件签名和时间戳
    if err := validateEvent(event); err != nil {
        return "", fmt.Errorf("事件验证失败: %v", err)
    }
    
    // 根据事件类型进行处理
    switch event.InfoType {
    case "authorized":
        authorizedEvent := &AuthorizedEvent{
            AuthorizationEvent: *event,
        }
        
        if err := eventHandler.HandleAuthorized(ctx, authorizedEvent); err != nil {
            // 记录错误日志，但依然返回success
            log.Printf("处理授权成功事件失败: %v", err)
        }
        
    case "unauthorized":
        unauthorizedEvent := &UnauthorizedEvent{
            AuthorizationEvent: *event,
        }
        
        if err := eventHandler.HandleUnauthorized(ctx, unauthorizedEvent); err != nil {
            // 记录错误日志，但依然返回success
            log.Printf("处理取消授权事件失败: %v", err)
        }
        
    case "updateauthorized":
        updateAuthorizedEvent := &UpdateAuthorizedEvent{
            AuthorizationEvent: *event,
        }
        
        if err := eventHandler.HandleUpdateAuthorized(ctx, updateAuthorizedEvent); err != nil {
            // 记录错误日志，但依然返回success
            log.Printf("处理授权更新事件失败: %v", err)
        }
        
    default:
        log.Printf("收到未知的事件类型: %s", event.InfoType)
    }
    
    // 根据微信官方文档要求，必须返回"success"字符串
    return "success", nil
}

// 验证事件签名和时间戳
func validateEvent(event *AuthorizationEvent) error {
    // 验证AppID是否匹配
    if event.AppId != expectedComponentAppID {
        return fmt.Errorf("AppID不匹配")
    }
    
    // 验证时间戳，防止重放攻击
    currentTime := time.Now().Unix()
    if math.Abs(float64(currentTime-event.CreateTime)) > 300 { // 5分钟容忍
        return fmt.Errorf("时间戳过期")
    }
    
    return nil
}
```

## 完整示例

### 1. 自定义事件处理器

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "io"
    "net/http"
    "github.com/jcbowen/wego"
)

// 自定义事件处理器
type MyEventHandler struct {
    client *wego.OpenPlatformClient
    db     *sql.DB // 假设有数据库连接
}

func (h *MyEventHandler) HandleAuthorized(ctx context.Context, event *wego.AuthorizedEvent) error {
    fmt.Printf("🎉 新的授权成功: %s\n", event.AuthorizerAppid)
    
    // 1. 使用授权码获取授权信息
    authInfo, err := h.client.QueryAuth(ctx, event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取授权信息失败: %v", err)
    }
    
    // 2. 获取授权方详细信息
    authorizerInfo, err := h.client.GetAuthorizerInfo(ctx, event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("获取授权方信息失败: %v", err)
    }
    
    // 3. 存储到数据库
    err = h.saveAuthorization(authInfo, authorizerInfo)
    if err != nil {
        return fmt.Errorf("存储授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已保存\n", authorizerInfo.NickName)
    return nil
}

func (h *MyEventHandler) HandleUnauthorized(ctx context.Context, event *wego.UnauthorizedEvent) error {
    fmt.Printf("⚠️ 取消授权: %s\n", event.AuthorizerAppid)
    
    // 清理相关数据
    err := h.cleanupAuthorization(event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("清理授权数据失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 数据已清理\n", event.AuthorizerAppid)
    return nil
}

func (h *MyEventHandler) HandleUpdateAuthorized(ctx context.Context, event *wego.UpdateAuthorizedEvent) error {
    fmt.Printf("🔄 授权更新: %s\n", event.AuthorizerAppid)
    
    // 重新获取授权信息
    authInfo, err := h.client.QueryAuth(ctx, event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取更新授权信息失败: %v", err)
    }
    
    // 更新数据库中的授权信息
    err = h.updateAuthorization(authInfo)
    if err != nil {
        return fmt.Errorf("更新授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已更新\n", event.AuthorizerAppid)
    return nil
}

// 数据库操作方法（示例）
func (h *MyEventHandler) saveAuthorization(authInfo *wego.AuthorizationInfo, authorizerInfo *wego.AuthorizerInfo) error {
    // 实现数据库存储逻辑
    return nil
}

func (h *MyEventHandler) cleanupAuthorization(appID string) error {
    // 实现数据清理逻辑
    return nil
}

func (h *MyEventHandler) updateAuthorization(authInfo *wego.AuthorizationInfo) error {
    // 实现数据更新逻辑
    return nil
}
```

### 2. 集成到HTTP服务器

```go
func main() {
    config := &wego.OpenPlatformConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewOpenPlatformClient(config)
    
    // 设置自定义事件处理器
    eventHandler := &MyEventHandler{client: client, db: yourDB}
    client.SetEventHandler(eventHandler)
    
    // HTTP消息处理
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        // 验证签名和解析消息
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        
        body, _ := io.ReadAll(r.Body)
        msg, err := client.DecryptMessage(string(body), signature, timestamp, nonce)
        if err != nil {
            http.Error(w, "消息处理失败", http.StatusBadRequest)
            return
        }
        
        // 处理不同类型的消息
        var response *wego.MessageResponse
        
        switch msg.InfoType {
        case "authorized", "unauthorized", "updateauthorized":
            response, err = client.HandleAuthorizationEvent(r.Context(), msg)
            
        case "component_verify_ticket":
            response, err = client.HandleVerifyTicket(r.Context(), msg)
            
        default:
            fmt.Printf("收到未知消息类型: %s\n", msg.InfoType)
            response = &wego.MessageResponse{ErrCode: 0, ErrMsg: "ok"}
        }
        
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/xml")
        w.Write([]byte(response.ToXML()))
    })
    
    http.ListenAndServe(":8080", nil)
}
```

## 事件处理最佳实践

### 1. 幂等性处理
确保事件处理是幂等的，避免重复处理导致数据不一致。

### 2. 异步处理
对于耗时的操作（如数据库操作、API调用），建议使用异步处理。

### 3. 错误处理
实现完善的错误处理机制，记录错误日志，确保服务稳定性。

### 4. 监控告警
设置监控告警，及时发现和处理事件处理异常。

## 注意事项

### 1. 消息验证
- 始终验证消息签名
- 检查时间戳防止重放攻击
- 验证AppID匹配

### 2. 响应要求
- 必须在5秒内返回响应
- 响应格式必须正确
- 错误时返回适当的错误码

### 3. 数据一致性
- 确保事件处理的数据一致性
- 实现事务处理机制
- 处理并发事件

## 常见问题

### Q: 收不到授权变更事件
A: 检查服务器配置、网络连接、消息签名验证

### Q: 事件处理超时
A: 优化处理逻辑，实现异步处理，确保5秒内响应

### Q: 重复事件处理
A: 实现幂等性处理，检查事件ID或时间戳

## 相关API

- `HandleAuthorizationEvent()` - 处理授权变更事件
- `SetEventHandler()` - 设置自定义事件处理器
- `QueryAuth()` - 使用授权码获取授权信息
- `GetAuthorizerInfo()` - 获取授权方详细信息

通过wxopen组件，您可以轻松处理各种授权变更事件，确保第三方平台服务的稳定运行。