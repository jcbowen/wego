# 03-授权变更通知推送

## 概述

授权变更通知推送是微信开放平台在授权状态发生变化时，向第三方平台推送的事件通知。WeGo库提供了完整的事件处理机制，支持多种授权变更事件的接收和处理。

## 事件类型

### 1. 授权成功事件 (authorized)
当公众号/服务号/小程序/微信小店/带货助手/视频号助手对第三方平台进行授权时触发。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

### 2. 取消授权事件 (unauthorized)  
当公众号/服务号/小程序/微信小店/带货助手/视频号助手取消对第三方平台的授权时触发。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

### 3. 授权更新事件 (updateauthorized)
当授权方更新授权时触发。如果更新授权时，授权的权限集没有发生变化，将不会触发授权更新通知。<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>

## 事件推送格式

### XML格式示例

```xml
<!-- 授权成功事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[authorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>

<!-- 取消授权事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[unauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
</xml>

<!-- 授权更新事件 -->
<xml>
  <AppId><![CDATA[第三方平台AppID]]></AppId>
  <CreateTime>1413192760</CreateTime>
  <InfoType><![CDATA[updateauthorized]]></InfoType>
  <AuthorizerAppid><![CDATA[授权方AppID]]></AuthorizerAppid>
  <AuthorizationCode><![CDATA[授权码]]></AuthorizationCode>
  <AuthorizationCodeExpiredTime>1413196360</AuthorizationCodeExpiredTime>
  <PreAuthCode><![CDATA[预授权码]]></PreAuthCode>
</xml>
```

## 事件处理实现

### 事件处理器接口

WeGo库定义了完整的事件处理器接口，支持自定义事件处理逻辑：

```go
// EventHandler 事件处理器接口
type EventHandler interface {
    // HandleAuthorized 处理授权成功事件
    HandleAuthorized(ctx context.Context, event *AuthorizedEvent) error

    // HandleUnauthorized 处理取消授权事件  
    HandleUnauthorized(ctx context.Context, event *UnauthorizedEvent) error

    // HandleUpdateAuthorized 处理授权更新事件
    HandleUpdateAuthorized(ctx context.Context, event *UpdateAuthorizedEvent) error

    // HandleComponentVerifyTicket 处理验证票据推送事件
    // 根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="0">0</mcreference>，
    // 接收POST请求后只需直接返回字符串"success"
    HandleComponentVerifyTicket(ctx context.Context, event *ComponentVerifyTicketEvent) error

    // HandleEncodingAESKeyChanged 处理EncodingAESKey变更事件
    // 当第三方平台在微信开放平台后台修改EncodingAESKey时，微信服务器会推送此事件
    // 根据微信官方规范<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Message_encryption_and_decryption.html" index="1">1</mcreference>，
    // 需要保存上一次的EncodingAESKey以确保平滑过渡
    HandleEncodingAESKeyChanged(ctx context.Context, event *EncodingAESKeyChangedEvent) error
}

// DefaultEventHandler 默认事件处理器
type DefaultEventHandler struct{}

func (h *DefaultEventHandler) HandleAuthorized(ctx context.Context, event *AuthorizedEvent) error {
    return nil
}

func (h *DefaultEventHandler) HandleUnauthorized(ctx context.Context, event *UnauthorizedEvent) error {
    return nil
}

func (h *DefaultEventHandler) HandleUpdateAuthorized(ctx context.Context, event *UpdateAuthorizedEvent) error {
    return nil
}

func (h *DefaultEventHandler) HandleComponentVerifyTicket(ctx context.Context, event *ComponentVerifyTicketEvent) error {
    // 根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/component_verify_ticket.html" index="0">0</mcreference>，
    // 接收POST请求后只需直接返回字符串"success"
    // 这里可以添加票据存储逻辑，但即使处理失败也必须返回success
    return nil
}

func (h *DefaultEventHandler) HandleEncodingAESKeyChanged(ctx context.Context, event *EncodingAESKeyChangedEvent) error {
    return nil
}
```

### 事件处理流程

根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>，接收POST请求后只需直接返回字符串"success"。WeGo库提供了完整的HandleAuthorizationEvent方法，支持明文和加密两种消息格式：

```go
// HandleAuthorizationEvent 处理微信开放平台授权事件
// 支持明文和加密两种消息格式
// 根据微信官方文档<mcreference link="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/authorize_event.html" index="0">0</mcreference>，
// 接收POST请求后只需直接返回字符串"success"
func (c *APIClient) HandleAuthorizationEvent(ctx context.Context, msgSignature, timestamp, nonce, encryptType string, body []byte) (string, error) {
    // 首先检测是否为加密消息
    var encryptedMsg struct {
        XMLName    xml.Name `xml:"xml"`
        AppId      string   `xml:"AppId"`
        Encrypt    string   `xml:"Encrypt"`
        CreateTime int64    `xml:"CreateTime"`
    }

    // 判断消息类型：根据encrypt_type参数或XML内容检测
    isEncrypted := encryptType == "aes" && msgSignature != ""

    // 如果URL参数表明是加密消息，或者XML内容包含Encrypt字段，则进行解密
    if isEncrypted {
        // 尝试解析XML获取加密内容
        if err := xml.Unmarshal(xmlData, &encryptedMsg); err != nil {
            return "success", nil // 即使解析失败也返回success
        }

        if encryptedMsg.Encrypt == "" {
            return "success", nil
        }

        // 解密消息
        decryptedData, err := c.DecryptMessage(encryptedMsg.Encrypt, msgSignature, timestamp, nonce)
        if err != nil {
            return "success", nil // 即使解密失败也返回success
        }

        // 使用解密后的数据继续处理
        xmlData = decryptedData
    }

    // 解析XML获取基础事件信息
    var baseEvent AuthorizationEvent
    err := xml.Unmarshal(xmlData, &baseEvent)
    if err != nil {
        return "success", nil // 即使解析失败也返回success
    }

    // 验证事件签名和时间戳
    if err := c.validateAuthorizationEvent(&baseEvent); err != nil {
        return "success", nil // 即使验证失败也返回success
    }

    // 根据事件类型进行处理
    switch baseEvent.InfoType {
    case "authorized":
        var event AuthorizedEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        if err := c.GetEventHandler().HandleAuthorized(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }

    case "unauthorized":
        var event UnauthorizedEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        if err := c.GetEventHandler().HandleUnauthorized(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }

    case "updateauthorized":
        var event UpdateAuthorizedEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        if err := c.GetEventHandler().HandleUpdateAuthorized(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }

    case "component_verify_ticket":
        var event ComponentVerifyTicketEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        // 存储验证票据
        if err := c.storage.SaveVerifyTicket(ctx, event.ComponentVerifyTicket); err != nil {
            // 记录错误日志，但依然返回success
        }

        if err := c.GetEventHandler().HandleComponentVerifyTicket(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }

    case "encoding_aes_key_changed":
        var event EncodingAESKeyChangedEvent
        err := xml.Unmarshal(xmlData, &event)
        if err != nil {
            break
        }

        // 保存上一次的EncodingAESKey
        if c.crypt != nil {
            c.crypt.SetPrevEncodingAESKey(c.config.EncodingAESKey)
        }

        // 更新配置中的EncodingAESKey
        c.config.EncodingAESKey = event.NewEncodingAESKey

        if err := c.GetEventHandler().HandleEncodingAESKeyChanged(ctx, &event); err != nil {
            // 记录错误日志，但依然返回success
        }

    default:
        // 记录未知事件类型日志
    }

    // 根据微信官方文档要求，必须返回"success"字符串
    return "success", nil
}
```

## 完整示例

### 1. 自定义事件处理器

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "io"
    "net/http"
    "github.com/jcbowen/wego"
)

// 自定义事件处理器
type MyEventHandler struct {
    client *wego.OpenPlatformClient
    db     *sql.DB // 假设有数据库连接
}

func (h *MyEventHandler) HandleAuthorized(ctx context.Context, event *wego.AuthorizedEvent) error {
    fmt.Printf("🎉 新的授权成功: %s\n", event.AuthorizerAppid)
    
    // 1. 使用授权码获取授权信息
    authInfo, err := h.client.QueryAuth(ctx, event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取授权信息失败: %v", err)
    }
    
    // 2. 获取授权方详细信息
    authorizerInfo, err := h.client.GetAuthorizerInfo(ctx, event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("获取授权方信息失败: %v", err)
    }
    
    // 3. 存储到数据库
    err = h.saveAuthorization(authInfo, authorizerInfo)
    if err != nil {
        return fmt.Errorf("存储授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已保存\n", authorizerInfo.NickName)
    return nil
}

func (h *MyEventHandler) HandleUnauthorized(ctx context.Context, event *wego.UnauthorizedEvent) error {
    fmt.Printf("⚠️ 取消授权: %s\n", event.AuthorizerAppid)
    
    // 清理相关数据
    err := h.cleanupAuthorization(event.AuthorizerAppid)
    if err != nil {
        return fmt.Errorf("清理授权数据失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 数据已清理\n", event.AuthorizerAppid)
    return nil
}

func (h *MyEventHandler) HandleUpdateAuthorized(ctx context.Context, event *wego.UpdateAuthorizedEvent) error {
    fmt.Printf("🔄 授权更新: %s\n", event.AuthorizerAppid)
    
    // 重新获取授权信息
    authInfo, err := h.client.QueryAuth(ctx, event.AuthorizationCode)
    if err != nil {
        return fmt.Errorf("获取更新授权信息失败: %v", err)
    }
    
    // 更新数据库中的授权信息
    err = h.updateAuthorization(authInfo)
    if err != nil {
        return fmt.Errorf("更新授权信息失败: %v", err)
    }
    
    fmt.Printf("✅ 授权方 %s 信息已更新\n", event.AuthorizerAppid)
    return nil
}

// 数据库操作方法（示例）
func (h *MyEventHandler) saveAuthorization(authInfo *wego.AuthorizationInfo, authorizerInfo *wego.AuthorizerInfo) error {
    // 实现数据库存储逻辑
    return nil
}

func (h *MyEventHandler) cleanupAuthorization(appID string) error {
    // 实现数据清理逻辑
    return nil
}

func (h *MyEventHandler) updateAuthorization(authInfo *wego.AuthorizationInfo) error {
    // 实现数据更新逻辑
    return nil
}
```

### 2. 集成到HTTP服务器

```go
func main() {
    config := &wego.OpenPlatformConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewOpenPlatformClient(config)
    
    // 设置自定义事件处理器
    eventHandler := &MyEventHandler{client: client, db: yourDB}
    client.SetEventHandler(eventHandler)
    
    // HTTP消息处理
    http.HandleFunc("/wego/callback", func(w http.ResponseWriter, r *http.Request) {
        // 获取URL参数
        signature := r.URL.Query().Get("msg_signature")
        timestamp := r.URL.Query().Get("timestamp")
        nonce := r.URL.Query().Get("nonce")
        encryptType := r.URL.Query().Get("encrypt_type")
        
        // 读取请求体
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "读取请求体失败", http.StatusBadRequest)
            return
        }
        
        // 使用HandleAuthorizationEvent方法处理授权事件
        response, err := client.HandleAuthorizationEvent(r.Context(), body, signature, timestamp, nonce, encryptType)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        // 返回响应
        w.Header().Set("Content-Type", "text/plain")
        w.Write([]byte(response))
    })
    
    http.ListenAndServe(":8080", nil)
}
```

## 事件处理最佳实践

### 1. 幂等性处理
确保事件处理是幂等的，避免重复处理导致数据不一致。

### 2. 异步处理
对于耗时的操作（如数据库操作、API调用），建议使用异步处理。

### 3. 错误处理
实现完善的错误处理机制，记录错误日志，确保服务稳定性。

### 4. 监控告警
设置监控告警，及时发现和处理事件处理异常。

## 注意事项

### 1. 消息验证
- 始终验证消息签名
- 检查时间戳防止重放攻击
- 验证AppID匹配

### 2. 响应要求
- 必须在5秒内返回响应
- 响应格式必须正确
- 错误时返回适当的错误码

### 3. 数据一致性
- 确保事件处理的数据一致性
- 实现事务处理机制
- 处理并发事件

## 常见问题

### Q: 收不到授权变更事件
A: 检查服务器配置、网络连接、消息签名验证

### Q: 事件处理超时
A: 优化处理逻辑，实现异步处理，确保5秒内响应

### Q: 重复事件处理
A: 实现幂等性处理，检查事件ID或时间戳

## 相关API

- `HandleAuthorizationEvent(ctx context.Context, msgSignature, timestamp, nonce, encryptType string, body []byte) (string, error)` - 处理授权变更事件，支持明文和加密消息格式
- `SetEventHandler(handler EventHandler)` - 设置自定义事件处理器
- `QueryAuth(ctx context.Context, authorizationCode string) (*AuthorizationInfo, error)` - 使用授权码获取授权信息
- `GetAuthorizerInfo(ctx context.Context, authorizerAppID string) (*AuthorizerInfo, error)` - 获取授权方详细信息
- `DecryptMessage(encryptedMsg, msgSignature, timestamp, nonce string) ([]byte, error)` - 解密加密消息
- `GetEventHandler() EventHandler` - 获取当前事件处理器

通过wxopen组件，您可以轻松处理各种授权变更事件，确保第三方平台服务的稳定运行。