# 08-代调用接口介绍

## 概述

代调用接口是第三方平台代授权方（公众号/小程序）调用微信API的核心功能。wxopen组件提供了完整的代调用接口实现，支持各种微信API的代理调用。

## 代调用原理

### 1. 调用流程
1. 获取授权方AccessToken
2. 构造API请求参数
3. 发送HTTP请求到微信服务器
4. 处理API响应结果
5. 错误处理和重试机制

### 2. 权限说明
- 第三方平台需要获得相应权限
- 授权方需要授权相应接口
- 接口调用受频率限制

## wxopen组件实现

### AuthorizerClient结构

```go
// AuthorizerClient 授权方客户端
type AuthorizerClient struct {
    appID string           // 授权方AppID
    client *WxOpenClient   // 第三方平台客户端
}

// 创建授权方客户端
func (client *WxOpenClient) GetAuthorizerClient(appID string) *AuthorizerClient {
    return &AuthorizerClient{
        appID:  appID,
        client: client,
    }
}
```

### 代调用核心方法

```go
// 代调用API
func (ac *AuthorizerClient) CallAPI(apiURL string, params interface{}) ([]byte, error) {
    // 1. 获取授权方AccessToken
    accessToken, _, err := ac.client.GetAuthorizerAccessToken(ac.appID)
    if err != nil {
        return nil, fmt.Errorf("获取AccessToken失败: %v", err)
    }
    
    // 2. 构造完整URL
    fullURL := fmt.Sprintf("%s?access_token=%s", apiURL, accessToken)
    
    // 3. 发送HTTP请求
    var respBody []byte
    if params != nil {
        // POST请求
        jsonData, err := json.Marshal(params)
        if err != nil {
            return nil, fmt.Errorf("参数序列化失败: %v", err)
        }
        
        resp, err := http.Post(fullURL, "application/json", bytes.NewReader(jsonData))
        if err != nil {
            return nil, fmt.Errorf("API调用失败: %v", err)
        }
        defer resp.Body.Close()
        
        respBody, err = io.ReadAll(resp.Body)
        if err != nil {
            return nil, fmt.Errorf("读取响应失败: %v", err)
        }
    } else {
        // GET请求
        resp, err := http.Get(fullURL)
        if err != nil {
            return nil, fmt.Errorf("API调用失败: %v", err)
        }
        defer resp.Body.Close()
        
        respBody, err = io.ReadAll(resp.Body)
        if err != nil {
            return nil, fmt.Errorf("读取响应失败: %v", err)
        }
    }
    
    // 4. 解析响应
    var apiResp APIResponse
    if err := json.Unmarshal(respBody, &apiResp); err != nil {
        return nil, fmt.Errorf("响应解析失败: %v", err)
    }
    
    // 5. 检查错误码
    if apiResp.ErrCode != 0 {
        return nil, fmt.Errorf("API返回错误: %d - %s", apiResp.ErrCode, apiResp.ErrMsg)
    }
    
    return respBody, nil
}
```

## 常用API封装

### 1. 用户管理API

```go
// 获取用户列表
func (ac *AuthorizerClient) GetUserList(nextOpenID string) ([]string, int, int, string, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/user/get"
    
    params := map[string]interface{}{
        "next_openid": nextOpenID,
    }
    
    respBody, err := ac.CallAPI(apiURL, params)
    if err != nil {
        return nil, 0, 0, "", err
    }
    
    var result struct {
        Total int      `json:"total"`
        Count int      `json:"count"`
        Data  struct {
            OpenIDs []string `json:"openid"`
        } `json:"data"`
        NextOpenID string `json:"next_openid"`
    }
    
    if err := json.Unmarshal(respBody, &result); err != nil {
        return nil, 0, 0, "", err
    }
    
    return result.Data.OpenIDs, result.Total, result.Count, result.NextOpenID, nil
}

// 获取用户信息
func (ac *AuthorizerClient) GetUserInfo(openID string) (*UserInfo, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/user/info"
    
    params := map[string]interface{}{
        "openid": openID,
        "lang":   "zh_CN",
    }
    
    respBody, err := ac.CallAPI(apiURL, params)
    if err != nil {
        return nil, err
    }
    
    var userInfo UserInfo
    if err := json.Unmarshal(respBody, &userInfo); err != nil {
        return nil, err
    }
    
    return &userInfo, nil
}
```

### 2. 消息发送API

```go
// 发送客服消息
func (ac *AuthorizerClient) SendCustomMessage(openID string, message interface{}) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/message/custom/send"
    
    params := map[string]interface{}{
        "touser":  openID,
        "msgtype": getMessageType(message),
        getMessageType(message): message,
    }
    
    _, err := ac.CallAPI(apiURL, params)
    return err
}

// 发送文本消息
func (ac *AuthorizerClient) SendTextMessage(openID, content string) error {
    message := map[string]interface{}{
        "content": content,
    }
    return ac.SendCustomMessage(openID, message)
}

// 发送图片消息
func (ac *AuthorizerClient) SendImageMessage(openID, mediaID string) error {
    message := map[string]interface{}{
        "media_id": mediaID,
    }
    return ac.SendCustomMessage(openID, message)
}
```

### 3. 菜单管理API

```go
// 创建自定义菜单
func (ac *AuthorizerClient) CreateMenu(menu *Menu) error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/create"
    
    _, err := ac.CallAPI(apiURL, menu)
    return err
}

// 删除自定义菜单
func (ac *AuthorizerClient) DeleteMenu() error {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/delete"
    
    _, err := ac.CallAPI(apiURL, nil)
    return err
}

// 获取菜单
func (ac *AuthorizerClient) GetMenu() (*Menu, error) {
    apiURL := "https://api.weixin.qq.com/cgi-bin/menu/get"
    
    respBody, err := ac.CallAPI(apiURL, nil)
    if err != nil {
        return nil, err
    }
    
    var menu Menu
    if err := json.Unmarshal(respBody, &menu); err != nil {
        return nil, err
    }
    
    return &menu, nil
}
```

## 完整示例

### 1. 用户管理示例

```go
package main

import (
    "fmt"
    "github.com/jcbowen/jcbaseGo/component/wego"
)

func main() {
    config := &wego.WxOpenConfig{
        ComponentAppID:     "your_component_appid",
        ComponentAppSecret: "your_component_appsecret",
        ComponentToken:     "your_component_token",
        EncodingAESKey:     "your_encoding_aes_key",
    }
    
    client := wego.NewWxOpenClient(config)
    
    // 获取授权方客户端
    authorizerAppID := "授权方AppID"
    authorizerClient := client.GetAuthorizerClient(authorizerAppID)
    
    // 获取用户列表
    users, total, count, nextOpenID, err := authorizerClient.GetUserList("")
    if err != nil {
        fmt.Printf("获取用户列表失败: %v\n", err)
        return
    }
    
    fmt.Printf("用户总数: %d, 本次获取: %d\n", total, count)
    
    // 获取第一个用户的信息
    if len(users) > 0 {
        userInfo, err := authorizerClient.GetUserInfo(users[0])
        if err != nil {
            fmt.Printf("获取用户信息失败: %v\n", err)
            return
        }
        
        fmt.Printf("用户昵称: %s, 城市: %s\n", userInfo.Nickname, userInfo.City)
        
        // 发送欢迎消息
        err = authorizerClient.SendTextMessage(users[0], "欢迎使用我们的服务！")
        if err != nil {
            fmt.Printf("发送消息失败: %v\n", err)
            return
        }
        
        fmt.Println("欢迎消息发送成功！")
    }
}
```

### 2. 菜单管理示例

```go
func manageMenu(authorizerClient *wego.AuthorizerClient) error {
    // 创建菜单
    menu := &wego.Menu{
        Button: []wego.MenuButton{
            {
                Type: "click",
                Name: "今日歌曲",
                Key:  "V1001_TODAY_MUSIC",
            },
            {
                Name: "菜单",
                SubButton: []wego.MenuButton{
                    {
                        Type: "view",
                        Name: "搜索",
                        URL:  "http://www.soso.com/",
                    },
                    {
                        Type: "click",
                        Name: "赞一下我们",
                        Key:  "V1001_GOOD",
                    },
                },
            },
        },
    }
    
    // 创建菜单
    if err := authorizerClient.CreateMenu(menu); err != nil {
        return fmt.Errorf("创建菜单失败: %v", err)
    }
    
    fmt.Println("菜单创建成功！")
    
    // 获取菜单
    currentMenu, err := authorizerClient.GetMenu()
    if err != nil {
        return fmt.Errorf("获取菜单失败: %v", err)
    }
    
    fmt.Printf("当前菜单按钮数量: %d\n", len(currentMenu.Button))
    
    return nil
}
```

## 错误处理

### 1. Token过期处理

```go
// 带重试的API调用
func (ac *AuthorizerClient) CallAPIWithRetry(apiURL string, params interface{}, maxRetries int) ([]byte, error) {
    for i := 0; i < maxRetries; i++ {
        respBody, err := ac.CallAPI(apiURL, params)
        if err == nil {
            return respBody, nil
        }
        
        // 检查是否是Token过期错误
        if strings.Contains(err.Error(), "40001") || strings.Contains(err.Error(), "42001") {
            // Token过期，清除缓存并重试
            ac.client.storage.ClearAuthorizerAccessToken(ac.appID)
            continue
        }
        
        // 其他错误，直接返回
        return nil, err
    }
    
    return nil, fmt.Errorf("API调用重试%d次后失败", maxRetries)
}
```

### 2. 频率限制处理

```go
// 带频率控制的API调用
func (ac *AuthorizerClient) CallAPIWithRateLimit(apiURL string, params interface{}) ([]byte, error) {
    // 检查频率限制
    if !ac.rateLimiter.Allow() {
        return nil, fmt.Errorf("频率限制，请稍后重试")
    }
    
    return ac.CallAPI(apiURL, params)
}
```

## 最佳实践

### 1. 缓存策略
- 缓存AccessToken减少API调用
- 实现Token自动刷新机制
- 设置合理的缓存过期时间

### 2. 错误处理
- 实现完善的错误日志记录
- 处理网络异常和重试机制
- 监控API调用成功率

### 3. 性能优化
- 使用连接池提高性能
- 实现批量操作减少API调用
- 异步处理耗时操作

## 注意事项

### 1. 权限控制
- 确保第三方平台有相应权限
- 检查授权方的接口权限
- 处理权限不足的错误

### 2. 频率限制
- 遵守微信API调用频率限制
- 实现合理的调用间隔
- 监控调用频率避免被封

### 3. 安全性
- 保护AccessToken不被泄露
- 使用HTTPS加密通信
- 验证API响应签名

通过wxopen组件的代调用接口功能，您可以轻松实现各种微信API的代理调用，为授权方提供丰富的功能服务。